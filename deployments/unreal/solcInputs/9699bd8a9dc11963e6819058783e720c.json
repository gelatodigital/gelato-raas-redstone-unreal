{
  "language": "Solidity",
  "sources": {
    "@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface AggregatorV3Interface {\n  function decimals() external view returns (uint8);\n\n  function description() external view returns (string memory);\n\n  function version() external view returns (uint256);\n\n  function getRoundData(uint80 _roundId)\n    external\n    view\n    returns (\n      uint80 roundId,\n      int256 answer,\n      uint256 startedAt,\n      uint256 updatedAt,\n      uint80 answeredInRound\n    );\n\n  function latestRoundData()\n    external\n    view\n    returns (\n      uint80 roundId,\n      int256 answer,\n      uint256 startedAt,\n      uint256 updatedAt,\n      uint80 answeredInRound\n    );\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.1) (proxy/utils/Initializable.sol)\n\npragma solidity ^0.8.2;\n\nimport \"../../utils/AddressUpgradeable.sol\";\n\n/**\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\n * behind a proxy. Since proxied contracts do not make use of a constructor, it's common to move constructor logic to an\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\n *\n * The initialization functions use a version number. Once a version number is used, it is consumed and cannot be\n * reused. This mechanism prevents re-execution of each \"step\" but allows the creation of new initialization steps in\n * case an upgrade adds a module that needs to be initialized.\n *\n * For example:\n *\n * [.hljs-theme-light.nopadding]\n * ```\n * contract MyToken is ERC20Upgradeable {\n *     function initialize() initializer public {\n *         __ERC20_init(\"MyToken\", \"MTK\");\n *     }\n * }\n * contract MyTokenV2 is MyToken, ERC20PermitUpgradeable {\n *     function initializeV2() reinitializer(2) public {\n *         __ERC20Permit_init(\"MyToken\");\n *     }\n * }\n * ```\n *\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\n * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\n *\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\n *\n * [CAUTION]\n * ====\n * Avoid leaving a contract uninitialized.\n *\n * An uninitialized contract can be taken over by an attacker. This applies to both a proxy and its implementation\n * contract, which may impact the proxy. To prevent the implementation contract from being used, you should invoke\n * the {_disableInitializers} function in the constructor to automatically lock it when it is deployed:\n *\n * [.hljs-theme-light.nopadding]\n * ```\n * /// @custom:oz-upgrades-unsafe-allow constructor\n * constructor() {\n *     _disableInitializers();\n * }\n * ```\n * ====\n */\nabstract contract Initializable {\n    /**\n     * @dev Indicates that the contract has been initialized.\n     * @custom:oz-retyped-from bool\n     */\n    uint8 private _initialized;\n\n    /**\n     * @dev Indicates that the contract is in the process of being initialized.\n     */\n    bool private _initializing;\n\n    /**\n     * @dev Triggered when the contract has been initialized or reinitialized.\n     */\n    event Initialized(uint8 version);\n\n    /**\n     * @dev A modifier that defines a protected initializer function that can be invoked at most once. In its scope,\n     * `onlyInitializing` functions can be used to initialize parent contracts.\n     *\n     * Similar to `reinitializer(1)`, except that functions marked with `initializer` can be nested in the context of a\n     * constructor.\n     *\n     * Emits an {Initialized} event.\n     */\n    modifier initializer() {\n        bool isTopLevelCall = !_initializing;\n        require(\n            (isTopLevelCall && _initialized < 1) || (!AddressUpgradeable.isContract(address(this)) && _initialized == 1),\n            \"Initializable: contract is already initialized\"\n        );\n        _initialized = 1;\n        if (isTopLevelCall) {\n            _initializing = true;\n        }\n        _;\n        if (isTopLevelCall) {\n            _initializing = false;\n            emit Initialized(1);\n        }\n    }\n\n    /**\n     * @dev A modifier that defines a protected reinitializer function that can be invoked at most once, and only if the\n     * contract hasn't been initialized to a greater version before. In its scope, `onlyInitializing` functions can be\n     * used to initialize parent contracts.\n     *\n     * A reinitializer may be used after the original initialization step. This is essential to configure modules that\n     * are added through upgrades and that require initialization.\n     *\n     * When `version` is 1, this modifier is similar to `initializer`, except that functions marked with `reinitializer`\n     * cannot be nested. If one is invoked in the context of another, execution will revert.\n     *\n     * Note that versions can jump in increments greater than 1; this implies that if multiple reinitializers coexist in\n     * a contract, executing them in the right order is up to the developer or operator.\n     *\n     * WARNING: setting the version to 255 will prevent any future reinitialization.\n     *\n     * Emits an {Initialized} event.\n     */\n    modifier reinitializer(uint8 version) {\n        require(!_initializing && _initialized < version, \"Initializable: contract is already initialized\");\n        _initialized = version;\n        _initializing = true;\n        _;\n        _initializing = false;\n        emit Initialized(version);\n    }\n\n    /**\n     * @dev Modifier to protect an initialization function so that it can only be invoked by functions with the\n     * {initializer} and {reinitializer} modifiers, directly or indirectly.\n     */\n    modifier onlyInitializing() {\n        require(_initializing, \"Initializable: contract is not initializing\");\n        _;\n    }\n\n    /**\n     * @dev Locks the contract, preventing any future reinitialization. This cannot be part of an initializer call.\n     * Calling this in the constructor of a contract will prevent that contract from being initialized or reinitialized\n     * to any version. It is recommended to use this to lock implementation contracts that are designed to be called\n     * through proxies.\n     *\n     * Emits an {Initialized} event the first time it is successfully executed.\n     */\n    function _disableInitializers() internal virtual {\n        require(!_initializing, \"Initializable: contract is initializing\");\n        if (_initialized < type(uint8).max) {\n            _initialized = type(uint8).max;\n            emit Initialized(type(uint8).max);\n        }\n    }\n\n    /**\n     * @dev Returns the highest version that has been initialized. See {reinitializer}.\n     */\n    function _getInitializedVersion() internal view returns (uint8) {\n        return _initialized;\n    }\n\n    /**\n     * @dev Returns `true` if the contract is currently initializing. See {onlyInitializing}.\n     */\n    function _isInitializing() internal view returns (bool) {\n        return _initializing;\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/Address.sol)\n\npragma solidity ^0.8.1;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary AddressUpgradeable {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\n     *\n     * _Available since v4.8._\n     */\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        if (success) {\n            if (returndata.length == 0) {\n                // only check isContract if the call was successful and the return data is empty\n                // otherwise we already know that it was a contract\n                require(isContract(target), \"Address: call to non-contract\");\n            }\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    /**\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason or using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\n        // Look for revert reason and bubble it up if present\n        if (returndata.length > 0) {\n            // The easiest way to bubble the revert reason is using memory via assembly\n            /// @solidity memory-safe-assembly\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert(errorMessage);\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/math/SafeCast.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/math/SafeCast.sol)\n// This file was procedurally generated from scripts/generate/templates/SafeCast.js.\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Wrappers over Solidity's uintXX/intXX casting operators with added overflow\n * checks.\n *\n * Downcasting from uint256/int256 in Solidity does not revert on overflow. This can\n * easily result in undesired exploitation or bugs, since developers usually\n * assume that overflows raise errors. `SafeCast` restores this intuition by\n * reverting the transaction when such an operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n *\n * Can be combined with {SafeMath} and {SignedSafeMath} to extend it to smaller types, by performing\n * all math on `uint256` and `int256` and then downcasting.\n */\nlibrary SafeCast {\n    /**\n     * @dev Returns the downcasted uint248 from uint256, reverting on\n     * overflow (when the input is greater than largest uint248).\n     *\n     * Counterpart to Solidity's `uint248` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 248 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint248(uint256 value) internal pure returns (uint248) {\n        require(value <= type(uint248).max, \"SafeCast: value doesn't fit in 248 bits\");\n        return uint248(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint240 from uint256, reverting on\n     * overflow (when the input is greater than largest uint240).\n     *\n     * Counterpart to Solidity's `uint240` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 240 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint240(uint256 value) internal pure returns (uint240) {\n        require(value <= type(uint240).max, \"SafeCast: value doesn't fit in 240 bits\");\n        return uint240(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint232 from uint256, reverting on\n     * overflow (when the input is greater than largest uint232).\n     *\n     * Counterpart to Solidity's `uint232` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 232 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint232(uint256 value) internal pure returns (uint232) {\n        require(value <= type(uint232).max, \"SafeCast: value doesn't fit in 232 bits\");\n        return uint232(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint224 from uint256, reverting on\n     * overflow (when the input is greater than largest uint224).\n     *\n     * Counterpart to Solidity's `uint224` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 224 bits\n     *\n     * _Available since v4.2._\n     */\n    function toUint224(uint256 value) internal pure returns (uint224) {\n        require(value <= type(uint224).max, \"SafeCast: value doesn't fit in 224 bits\");\n        return uint224(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint216 from uint256, reverting on\n     * overflow (when the input is greater than largest uint216).\n     *\n     * Counterpart to Solidity's `uint216` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 216 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint216(uint256 value) internal pure returns (uint216) {\n        require(value <= type(uint216).max, \"SafeCast: value doesn't fit in 216 bits\");\n        return uint216(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint208 from uint256, reverting on\n     * overflow (when the input is greater than largest uint208).\n     *\n     * Counterpart to Solidity's `uint208` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 208 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint208(uint256 value) internal pure returns (uint208) {\n        require(value <= type(uint208).max, \"SafeCast: value doesn't fit in 208 bits\");\n        return uint208(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint200 from uint256, reverting on\n     * overflow (when the input is greater than largest uint200).\n     *\n     * Counterpart to Solidity's `uint200` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 200 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint200(uint256 value) internal pure returns (uint200) {\n        require(value <= type(uint200).max, \"SafeCast: value doesn't fit in 200 bits\");\n        return uint200(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint192 from uint256, reverting on\n     * overflow (when the input is greater than largest uint192).\n     *\n     * Counterpart to Solidity's `uint192` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 192 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint192(uint256 value) internal pure returns (uint192) {\n        require(value <= type(uint192).max, \"SafeCast: value doesn't fit in 192 bits\");\n        return uint192(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint184 from uint256, reverting on\n     * overflow (when the input is greater than largest uint184).\n     *\n     * Counterpart to Solidity's `uint184` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 184 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint184(uint256 value) internal pure returns (uint184) {\n        require(value <= type(uint184).max, \"SafeCast: value doesn't fit in 184 bits\");\n        return uint184(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint176 from uint256, reverting on\n     * overflow (when the input is greater than largest uint176).\n     *\n     * Counterpart to Solidity's `uint176` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 176 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint176(uint256 value) internal pure returns (uint176) {\n        require(value <= type(uint176).max, \"SafeCast: value doesn't fit in 176 bits\");\n        return uint176(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint168 from uint256, reverting on\n     * overflow (when the input is greater than largest uint168).\n     *\n     * Counterpart to Solidity's `uint168` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 168 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint168(uint256 value) internal pure returns (uint168) {\n        require(value <= type(uint168).max, \"SafeCast: value doesn't fit in 168 bits\");\n        return uint168(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint160 from uint256, reverting on\n     * overflow (when the input is greater than largest uint160).\n     *\n     * Counterpart to Solidity's `uint160` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 160 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint160(uint256 value) internal pure returns (uint160) {\n        require(value <= type(uint160).max, \"SafeCast: value doesn't fit in 160 bits\");\n        return uint160(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint152 from uint256, reverting on\n     * overflow (when the input is greater than largest uint152).\n     *\n     * Counterpart to Solidity's `uint152` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 152 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint152(uint256 value) internal pure returns (uint152) {\n        require(value <= type(uint152).max, \"SafeCast: value doesn't fit in 152 bits\");\n        return uint152(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint144 from uint256, reverting on\n     * overflow (when the input is greater than largest uint144).\n     *\n     * Counterpart to Solidity's `uint144` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 144 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint144(uint256 value) internal pure returns (uint144) {\n        require(value <= type(uint144).max, \"SafeCast: value doesn't fit in 144 bits\");\n        return uint144(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint136 from uint256, reverting on\n     * overflow (when the input is greater than largest uint136).\n     *\n     * Counterpart to Solidity's `uint136` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 136 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint136(uint256 value) internal pure returns (uint136) {\n        require(value <= type(uint136).max, \"SafeCast: value doesn't fit in 136 bits\");\n        return uint136(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint128 from uint256, reverting on\n     * overflow (when the input is greater than largest uint128).\n     *\n     * Counterpart to Solidity's `uint128` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 128 bits\n     *\n     * _Available since v2.5._\n     */\n    function toUint128(uint256 value) internal pure returns (uint128) {\n        require(value <= type(uint128).max, \"SafeCast: value doesn't fit in 128 bits\");\n        return uint128(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint120 from uint256, reverting on\n     * overflow (when the input is greater than largest uint120).\n     *\n     * Counterpart to Solidity's `uint120` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 120 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint120(uint256 value) internal pure returns (uint120) {\n        require(value <= type(uint120).max, \"SafeCast: value doesn't fit in 120 bits\");\n        return uint120(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint112 from uint256, reverting on\n     * overflow (when the input is greater than largest uint112).\n     *\n     * Counterpart to Solidity's `uint112` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 112 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint112(uint256 value) internal pure returns (uint112) {\n        require(value <= type(uint112).max, \"SafeCast: value doesn't fit in 112 bits\");\n        return uint112(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint104 from uint256, reverting on\n     * overflow (when the input is greater than largest uint104).\n     *\n     * Counterpart to Solidity's `uint104` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 104 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint104(uint256 value) internal pure returns (uint104) {\n        require(value <= type(uint104).max, \"SafeCast: value doesn't fit in 104 bits\");\n        return uint104(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint96 from uint256, reverting on\n     * overflow (when the input is greater than largest uint96).\n     *\n     * Counterpart to Solidity's `uint96` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 96 bits\n     *\n     * _Available since v4.2._\n     */\n    function toUint96(uint256 value) internal pure returns (uint96) {\n        require(value <= type(uint96).max, \"SafeCast: value doesn't fit in 96 bits\");\n        return uint96(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint88 from uint256, reverting on\n     * overflow (when the input is greater than largest uint88).\n     *\n     * Counterpart to Solidity's `uint88` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 88 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint88(uint256 value) internal pure returns (uint88) {\n        require(value <= type(uint88).max, \"SafeCast: value doesn't fit in 88 bits\");\n        return uint88(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint80 from uint256, reverting on\n     * overflow (when the input is greater than largest uint80).\n     *\n     * Counterpart to Solidity's `uint80` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 80 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint80(uint256 value) internal pure returns (uint80) {\n        require(value <= type(uint80).max, \"SafeCast: value doesn't fit in 80 bits\");\n        return uint80(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint72 from uint256, reverting on\n     * overflow (when the input is greater than largest uint72).\n     *\n     * Counterpart to Solidity's `uint72` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 72 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint72(uint256 value) internal pure returns (uint72) {\n        require(value <= type(uint72).max, \"SafeCast: value doesn't fit in 72 bits\");\n        return uint72(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint64 from uint256, reverting on\n     * overflow (when the input is greater than largest uint64).\n     *\n     * Counterpart to Solidity's `uint64` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 64 bits\n     *\n     * _Available since v2.5._\n     */\n    function toUint64(uint256 value) internal pure returns (uint64) {\n        require(value <= type(uint64).max, \"SafeCast: value doesn't fit in 64 bits\");\n        return uint64(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint56 from uint256, reverting on\n     * overflow (when the input is greater than largest uint56).\n     *\n     * Counterpart to Solidity's `uint56` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 56 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint56(uint256 value) internal pure returns (uint56) {\n        require(value <= type(uint56).max, \"SafeCast: value doesn't fit in 56 bits\");\n        return uint56(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint48 from uint256, reverting on\n     * overflow (when the input is greater than largest uint48).\n     *\n     * Counterpart to Solidity's `uint48` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 48 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint48(uint256 value) internal pure returns (uint48) {\n        require(value <= type(uint48).max, \"SafeCast: value doesn't fit in 48 bits\");\n        return uint48(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint40 from uint256, reverting on\n     * overflow (when the input is greater than largest uint40).\n     *\n     * Counterpart to Solidity's `uint40` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 40 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint40(uint256 value) internal pure returns (uint40) {\n        require(value <= type(uint40).max, \"SafeCast: value doesn't fit in 40 bits\");\n        return uint40(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint32 from uint256, reverting on\n     * overflow (when the input is greater than largest uint32).\n     *\n     * Counterpart to Solidity's `uint32` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 32 bits\n     *\n     * _Available since v2.5._\n     */\n    function toUint32(uint256 value) internal pure returns (uint32) {\n        require(value <= type(uint32).max, \"SafeCast: value doesn't fit in 32 bits\");\n        return uint32(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint24 from uint256, reverting on\n     * overflow (when the input is greater than largest uint24).\n     *\n     * Counterpart to Solidity's `uint24` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 24 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint24(uint256 value) internal pure returns (uint24) {\n        require(value <= type(uint24).max, \"SafeCast: value doesn't fit in 24 bits\");\n        return uint24(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint16 from uint256, reverting on\n     * overflow (when the input is greater than largest uint16).\n     *\n     * Counterpart to Solidity's `uint16` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 16 bits\n     *\n     * _Available since v2.5._\n     */\n    function toUint16(uint256 value) internal pure returns (uint16) {\n        require(value <= type(uint16).max, \"SafeCast: value doesn't fit in 16 bits\");\n        return uint16(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint8 from uint256, reverting on\n     * overflow (when the input is greater than largest uint8).\n     *\n     * Counterpart to Solidity's `uint8` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 8 bits\n     *\n     * _Available since v2.5._\n     */\n    function toUint8(uint256 value) internal pure returns (uint8) {\n        require(value <= type(uint8).max, \"SafeCast: value doesn't fit in 8 bits\");\n        return uint8(value);\n    }\n\n    /**\n     * @dev Converts a signed int256 into an unsigned uint256.\n     *\n     * Requirements:\n     *\n     * - input must be greater than or equal to 0.\n     *\n     * _Available since v3.0._\n     */\n    function toUint256(int256 value) internal pure returns (uint256) {\n        require(value >= 0, \"SafeCast: value must be positive\");\n        return uint256(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int248 from int256, reverting on\n     * overflow (when the input is less than smallest int248 or\n     * greater than largest int248).\n     *\n     * Counterpart to Solidity's `int248` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 248 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt248(int256 value) internal pure returns (int248 downcasted) {\n        downcasted = int248(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 248 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int240 from int256, reverting on\n     * overflow (when the input is less than smallest int240 or\n     * greater than largest int240).\n     *\n     * Counterpart to Solidity's `int240` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 240 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt240(int256 value) internal pure returns (int240 downcasted) {\n        downcasted = int240(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 240 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int232 from int256, reverting on\n     * overflow (when the input is less than smallest int232 or\n     * greater than largest int232).\n     *\n     * Counterpart to Solidity's `int232` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 232 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt232(int256 value) internal pure returns (int232 downcasted) {\n        downcasted = int232(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 232 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int224 from int256, reverting on\n     * overflow (when the input is less than smallest int224 or\n     * greater than largest int224).\n     *\n     * Counterpart to Solidity's `int224` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 224 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt224(int256 value) internal pure returns (int224 downcasted) {\n        downcasted = int224(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 224 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int216 from int256, reverting on\n     * overflow (when the input is less than smallest int216 or\n     * greater than largest int216).\n     *\n     * Counterpart to Solidity's `int216` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 216 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt216(int256 value) internal pure returns (int216 downcasted) {\n        downcasted = int216(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 216 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int208 from int256, reverting on\n     * overflow (when the input is less than smallest int208 or\n     * greater than largest int208).\n     *\n     * Counterpart to Solidity's `int208` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 208 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt208(int256 value) internal pure returns (int208 downcasted) {\n        downcasted = int208(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 208 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int200 from int256, reverting on\n     * overflow (when the input is less than smallest int200 or\n     * greater than largest int200).\n     *\n     * Counterpart to Solidity's `int200` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 200 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt200(int256 value) internal pure returns (int200 downcasted) {\n        downcasted = int200(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 200 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int192 from int256, reverting on\n     * overflow (when the input is less than smallest int192 or\n     * greater than largest int192).\n     *\n     * Counterpart to Solidity's `int192` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 192 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt192(int256 value) internal pure returns (int192 downcasted) {\n        downcasted = int192(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 192 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int184 from int256, reverting on\n     * overflow (when the input is less than smallest int184 or\n     * greater than largest int184).\n     *\n     * Counterpart to Solidity's `int184` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 184 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt184(int256 value) internal pure returns (int184 downcasted) {\n        downcasted = int184(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 184 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int176 from int256, reverting on\n     * overflow (when the input is less than smallest int176 or\n     * greater than largest int176).\n     *\n     * Counterpart to Solidity's `int176` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 176 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt176(int256 value) internal pure returns (int176 downcasted) {\n        downcasted = int176(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 176 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int168 from int256, reverting on\n     * overflow (when the input is less than smallest int168 or\n     * greater than largest int168).\n     *\n     * Counterpart to Solidity's `int168` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 168 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt168(int256 value) internal pure returns (int168 downcasted) {\n        downcasted = int168(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 168 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int160 from int256, reverting on\n     * overflow (when the input is less than smallest int160 or\n     * greater than largest int160).\n     *\n     * Counterpart to Solidity's `int160` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 160 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt160(int256 value) internal pure returns (int160 downcasted) {\n        downcasted = int160(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 160 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int152 from int256, reverting on\n     * overflow (when the input is less than smallest int152 or\n     * greater than largest int152).\n     *\n     * Counterpart to Solidity's `int152` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 152 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt152(int256 value) internal pure returns (int152 downcasted) {\n        downcasted = int152(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 152 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int144 from int256, reverting on\n     * overflow (when the input is less than smallest int144 or\n     * greater than largest int144).\n     *\n     * Counterpart to Solidity's `int144` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 144 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt144(int256 value) internal pure returns (int144 downcasted) {\n        downcasted = int144(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 144 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int136 from int256, reverting on\n     * overflow (when the input is less than smallest int136 or\n     * greater than largest int136).\n     *\n     * Counterpart to Solidity's `int136` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 136 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt136(int256 value) internal pure returns (int136 downcasted) {\n        downcasted = int136(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 136 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int128 from int256, reverting on\n     * overflow (when the input is less than smallest int128 or\n     * greater than largest int128).\n     *\n     * Counterpart to Solidity's `int128` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 128 bits\n     *\n     * _Available since v3.1._\n     */\n    function toInt128(int256 value) internal pure returns (int128 downcasted) {\n        downcasted = int128(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 128 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int120 from int256, reverting on\n     * overflow (when the input is less than smallest int120 or\n     * greater than largest int120).\n     *\n     * Counterpart to Solidity's `int120` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 120 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt120(int256 value) internal pure returns (int120 downcasted) {\n        downcasted = int120(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 120 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int112 from int256, reverting on\n     * overflow (when the input is less than smallest int112 or\n     * greater than largest int112).\n     *\n     * Counterpart to Solidity's `int112` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 112 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt112(int256 value) internal pure returns (int112 downcasted) {\n        downcasted = int112(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 112 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int104 from int256, reverting on\n     * overflow (when the input is less than smallest int104 or\n     * greater than largest int104).\n     *\n     * Counterpart to Solidity's `int104` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 104 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt104(int256 value) internal pure returns (int104 downcasted) {\n        downcasted = int104(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 104 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int96 from int256, reverting on\n     * overflow (when the input is less than smallest int96 or\n     * greater than largest int96).\n     *\n     * Counterpart to Solidity's `int96` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 96 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt96(int256 value) internal pure returns (int96 downcasted) {\n        downcasted = int96(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 96 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int88 from int256, reverting on\n     * overflow (when the input is less than smallest int88 or\n     * greater than largest int88).\n     *\n     * Counterpart to Solidity's `int88` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 88 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt88(int256 value) internal pure returns (int88 downcasted) {\n        downcasted = int88(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 88 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int80 from int256, reverting on\n     * overflow (when the input is less than smallest int80 or\n     * greater than largest int80).\n     *\n     * Counterpart to Solidity's `int80` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 80 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt80(int256 value) internal pure returns (int80 downcasted) {\n        downcasted = int80(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 80 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int72 from int256, reverting on\n     * overflow (when the input is less than smallest int72 or\n     * greater than largest int72).\n     *\n     * Counterpart to Solidity's `int72` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 72 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt72(int256 value) internal pure returns (int72 downcasted) {\n        downcasted = int72(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 72 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int64 from int256, reverting on\n     * overflow (when the input is less than smallest int64 or\n     * greater than largest int64).\n     *\n     * Counterpart to Solidity's `int64` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 64 bits\n     *\n     * _Available since v3.1._\n     */\n    function toInt64(int256 value) internal pure returns (int64 downcasted) {\n        downcasted = int64(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 64 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int56 from int256, reverting on\n     * overflow (when the input is less than smallest int56 or\n     * greater than largest int56).\n     *\n     * Counterpart to Solidity's `int56` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 56 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt56(int256 value) internal pure returns (int56 downcasted) {\n        downcasted = int56(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 56 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int48 from int256, reverting on\n     * overflow (when the input is less than smallest int48 or\n     * greater than largest int48).\n     *\n     * Counterpart to Solidity's `int48` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 48 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt48(int256 value) internal pure returns (int48 downcasted) {\n        downcasted = int48(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 48 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int40 from int256, reverting on\n     * overflow (when the input is less than smallest int40 or\n     * greater than largest int40).\n     *\n     * Counterpart to Solidity's `int40` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 40 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt40(int256 value) internal pure returns (int40 downcasted) {\n        downcasted = int40(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 40 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int32 from int256, reverting on\n     * overflow (when the input is less than smallest int32 or\n     * greater than largest int32).\n     *\n     * Counterpart to Solidity's `int32` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 32 bits\n     *\n     * _Available since v3.1._\n     */\n    function toInt32(int256 value) internal pure returns (int32 downcasted) {\n        downcasted = int32(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 32 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int24 from int256, reverting on\n     * overflow (when the input is less than smallest int24 or\n     * greater than largest int24).\n     *\n     * Counterpart to Solidity's `int24` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 24 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt24(int256 value) internal pure returns (int24 downcasted) {\n        downcasted = int24(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 24 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int16 from int256, reverting on\n     * overflow (when the input is less than smallest int16 or\n     * greater than largest int16).\n     *\n     * Counterpart to Solidity's `int16` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 16 bits\n     *\n     * _Available since v3.1._\n     */\n    function toInt16(int256 value) internal pure returns (int16 downcasted) {\n        downcasted = int16(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 16 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int8 from int256, reverting on\n     * overflow (when the input is less than smallest int8 or\n     * greater than largest int8).\n     *\n     * Counterpart to Solidity's `int8` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 8 bits\n     *\n     * _Available since v3.1._\n     */\n    function toInt8(int256 value) internal pure returns (int8 downcasted) {\n        downcasted = int8(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 8 bits\");\n    }\n\n    /**\n     * @dev Converts an unsigned uint256 into a signed int256.\n     *\n     * Requirements:\n     *\n     * - input must be less than or equal to maxInt256.\n     *\n     * _Available since v3.0._\n     */\n    function toInt256(uint256 value) internal pure returns (int256) {\n        // Note: Unsafe cast below is okay because `type(int256).max` is guaranteed to be positive\n        require(value <= uint256(type(int256).max), \"SafeCast: value doesn't fit in an int256\");\n        return int256(value);\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/math/SafeMath.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/math/SafeMath.sol)\n\npragma solidity ^0.8.0;\n\n// CAUTION\n// This version of SafeMath should only be used with Solidity 0.8 or later,\n// because it relies on the compiler's built in overflow checks.\n\n/**\n * @dev Wrappers over Solidity's arithmetic operations.\n *\n * NOTE: `SafeMath` is generally not needed starting with Solidity 0.8, since the compiler\n * now has built in overflow checking.\n */\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            uint256 c = a + b;\n            if (c < a) return (false, 0);\n            return (true, c);\n        }\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b > a) return (false, 0);\n            return (true, a - b);\n        }\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n            // benefit is lost if 'b' is also tested.\n            // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n            if (a == 0) return (true, 0);\n            uint256 c = a * b;\n            if (c / a != b) return (false, 0);\n            return (true, c);\n        }\n    }\n\n    /**\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a / b);\n        }\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a % b);\n        }\n    }\n\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     *\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a + b;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a - b;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     *\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a * b;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers, reverting on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator.\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a / b;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * reverting when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a % b;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n     * overflow (when the result is negative).\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {trySub}.\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        unchecked {\n            require(b <= a, errorMessage);\n            return a - b;\n        }\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        unchecked {\n            require(b > 0, errorMessage);\n            return a / b;\n        }\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * reverting with custom message when dividing by zero.\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {tryMod}.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        unchecked {\n            require(b > 0, errorMessage);\n            return a % b;\n        }\n    }\n}\n"
    },
    "@redstone-finance/evm-connector/contracts/core/CalldataExtractor.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity ^0.8.4;\n\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\n\nimport \"./RedstoneConstants.sol\";\n\n/**\n * @title The base contract with the main logic of data extraction from calldata\n * @author The Redstone Oracles team\n * @dev This contract was created to reuse the same logic in the RedstoneConsumerBase\n * and the ProxyConnector contracts\n */\ncontract CalldataExtractor is RedstoneConstants {\n  using SafeMath for uint256;\n\n  error DataPackageTimestampMustNotBeZero();\n  error DataPackageTimestampsMustBeEqual();\n  error RedstonePayloadMustHaveAtLeastOneDataPackage();\n\n  function extractTimestampsAndAssertAllAreEqual() public pure returns (uint256 extractedTimestamp) {\n    uint256 calldataNegativeOffset = _extractByteSizeOfUnsignedMetadata();\n    uint256 dataPackagesCount = _extractDataPackagesCountFromCalldata(calldataNegativeOffset);\n\n    if (dataPackagesCount == 0) {\n      revert RedstonePayloadMustHaveAtLeastOneDataPackage();\n    }\n\n    calldataNegativeOffset += DATA_PACKAGES_COUNT_BS;\n    for (uint256 dataPackageIndex = 0; dataPackageIndex < dataPackagesCount; dataPackageIndex++) {\n      uint256 dataPackageByteSize = _getDataPackageByteSize(calldataNegativeOffset);\n\n      // Extracting timestamp for the current data package\n      uint48 dataPackageTimestamp; // uint48, because timestamp uses 6 bytes\n      uint256 timestampNegativeOffset = (calldataNegativeOffset + TIMESTAMP_NEGATIVE_OFFSET_IN_DATA_PACKAGE_WITH_STANDARD_SLOT_BS);\n      uint256 timestampOffset = msg.data.length - timestampNegativeOffset;\n      assembly {\n        dataPackageTimestamp := calldataload(timestampOffset)\n      }\n\n      if (dataPackageTimestamp == 0) {\n        revert DataPackageTimestampMustNotBeZero();\n      }\n\n      if (extractedTimestamp == 0) {\n        extractedTimestamp = dataPackageTimestamp;\n      } else if (dataPackageTimestamp != extractedTimestamp) {\n        revert DataPackageTimestampsMustBeEqual();\n      }\n\n      calldataNegativeOffset += dataPackageByteSize;\n    }\n  }\n\n  function _getDataPackageByteSize(uint256 calldataNegativeOffset) internal pure returns (uint256) {\n    (\n      uint256 dataPointsCount,\n      uint256 eachDataPointValueByteSize\n    ) = _extractDataPointsDetailsForDataPackage(calldataNegativeOffset);\n\n    return\n      dataPointsCount *\n      (DATA_POINT_SYMBOL_BS + eachDataPointValueByteSize) +\n      DATA_PACKAGE_WITHOUT_DATA_POINTS_BS;\n  }\n\n  function _extractByteSizeOfUnsignedMetadata() internal pure returns (uint256) {\n    // Checking if the calldata ends with the RedStone marker\n    bool hasValidRedstoneMarker;\n    assembly {\n      let calldataLast32Bytes := calldataload(sub(calldatasize(), STANDARD_SLOT_BS))\n      hasValidRedstoneMarker := eq(\n        REDSTONE_MARKER_MASK,\n        and(calldataLast32Bytes, REDSTONE_MARKER_MASK)\n      )\n    }\n    if (!hasValidRedstoneMarker) {\n      revert CalldataMustHaveValidPayload();\n    }\n\n    // Using uint24, because unsigned metadata byte size number has 3 bytes\n    uint24 unsignedMetadataByteSize;\n    if (REDSTONE_MARKER_BS_PLUS_STANDARD_SLOT_BS > msg.data.length) {\n      revert CalldataOverOrUnderFlow();\n    }\n    assembly {\n      unsignedMetadataByteSize := calldataload(\n        sub(calldatasize(), REDSTONE_MARKER_BS_PLUS_STANDARD_SLOT_BS)\n      )\n    }\n    uint256 calldataNegativeOffset = unsignedMetadataByteSize\n      + UNSIGNED_METADATA_BYTE_SIZE_BS\n      + REDSTONE_MARKER_BS;\n    if (calldataNegativeOffset + DATA_PACKAGES_COUNT_BS > msg.data.length) {\n      revert IncorrectUnsignedMetadataSize();\n    }\n    return calldataNegativeOffset;\n  }\n\n  // We return uint16, because unsigned metadata byte size number has 2 bytes\n  function _extractDataPackagesCountFromCalldata(uint256 calldataNegativeOffset)\n    internal\n    pure\n    returns (uint16 dataPackagesCount)\n  {\n    uint256 calldataNegativeOffsetWithStandardSlot = calldataNegativeOffset + STANDARD_SLOT_BS;\n    if (calldataNegativeOffsetWithStandardSlot > msg.data.length) {\n      revert CalldataOverOrUnderFlow();\n    }\n    assembly {\n      dataPackagesCount := calldataload(\n        sub(calldatasize(), calldataNegativeOffsetWithStandardSlot)\n      )\n    }\n    return dataPackagesCount;\n  }\n\n  function _extractDataPointValueAndDataFeedId(\n    uint256 calldataNegativeOffsetForDataPackage,\n    uint256 defaultDataPointValueByteSize,\n    uint256 dataPointIndex\n  ) internal pure virtual returns (bytes32 dataPointDataFeedId, uint256 dataPointValue) {\n    uint256 negativeOffsetToDataPoints = calldataNegativeOffsetForDataPackage + DATA_PACKAGE_WITHOUT_DATA_POINTS_BS;\n    uint256 dataPointNegativeOffset = negativeOffsetToDataPoints.add(\n      (1 + dataPointIndex).mul((defaultDataPointValueByteSize + DATA_POINT_SYMBOL_BS))\n    );\n    uint256 dataPointCalldataOffset = msg.data.length.sub(dataPointNegativeOffset);\n    assembly {\n      dataPointDataFeedId := calldataload(dataPointCalldataOffset)\n      dataPointValue := calldataload(add(dataPointCalldataOffset, DATA_POINT_SYMBOL_BS))\n    }\n  }\n\n  function _extractDataPointsDetailsForDataPackage(uint256 calldataNegativeOffsetForDataPackage)\n    internal\n    pure\n    returns (uint256 dataPointsCount, uint256 eachDataPointValueByteSize)\n  {\n    // Using uint24, because data points count byte size number has 3 bytes\n    uint24 dataPointsCount_;\n\n    // Using uint32, because data point value byte size has 4 bytes\n    uint32 eachDataPointValueByteSize_;\n\n    // Extract data points count\n    uint256 negativeCalldataOffset = calldataNegativeOffsetForDataPackage + SIG_BS;\n    uint256 calldataOffset = msg.data.length.sub(negativeCalldataOffset + STANDARD_SLOT_BS);\n    assembly {\n      dataPointsCount_ := calldataload(calldataOffset)\n    }\n\n    // Extract each data point value size\n    calldataOffset = calldataOffset.sub(DATA_POINTS_COUNT_BS);\n    assembly {\n      eachDataPointValueByteSize_ := calldataload(calldataOffset)\n    }\n\n    // Prepare returned values\n    dataPointsCount = dataPointsCount_;\n    eachDataPointValueByteSize = eachDataPointValueByteSize_;\n  }\n}\n"
    },
    "@redstone-finance/evm-connector/contracts/core/RedstoneConstants.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity ^0.8.4;\n\n/**\n * @title The base contract with helpful constants\n * @author The Redstone Oracles team\n * @dev It mainly contains redstone-related values, which improve readability\n * of other contracts (e.g. CalldataExtractor and RedstoneConsumerBase)\n */\ncontract RedstoneConstants {\n  // === Abbreviations ===\n  // BS - Bytes size\n  // PTR - Pointer (memory location)\n  // SIG - Signature\n\n  // Solidity and YUL constants\n  uint256 internal constant STANDARD_SLOT_BS = 32;\n  uint256 internal constant FREE_MEMORY_PTR = 0x40;\n  uint256 internal constant BYTES_ARR_LEN_VAR_BS = 32;\n  uint256 internal constant FUNCTION_SIGNATURE_BS = 4;\n  uint256 internal constant REVERT_MSG_OFFSET = 68; // Revert message structure described here: https://ethereum.stackexchange.com/a/66173/106364\n  uint256 internal constant STRING_ERR_MESSAGE_MASK = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n\n  // RedStone protocol consts\n  uint256 internal constant SIG_BS = 65;\n  uint256 internal constant TIMESTAMP_BS = 6;\n  uint256 internal constant DATA_PACKAGES_COUNT_BS = 2;\n  uint256 internal constant DATA_POINTS_COUNT_BS = 3;\n  uint256 internal constant DATA_POINT_VALUE_BYTE_SIZE_BS = 4;\n  uint256 internal constant DATA_POINT_SYMBOL_BS = 32;\n  uint256 internal constant DEFAULT_DATA_POINT_VALUE_BS = 32;\n  uint256 internal constant UNSIGNED_METADATA_BYTE_SIZE_BS = 3;\n  uint256 internal constant REDSTONE_MARKER_BS = 9; // byte size of 0x000002ed57011e0000\n  uint256 internal constant REDSTONE_MARKER_MASK = 0x0000000000000000000000000000000000000000000000000002ed57011e0000;\n\n  // Derived values (based on consts)\n  uint256 internal constant TIMESTAMP_NEGATIVE_OFFSET_IN_DATA_PACKAGE_WITH_STANDARD_SLOT_BS = 104; // SIG_BS + DATA_POINTS_COUNT_BS + DATA_POINT_VALUE_BYTE_SIZE_BS + STANDARD_SLOT_BS\n  uint256 internal constant DATA_PACKAGE_WITHOUT_DATA_POINTS_BS = 78; // DATA_POINT_VALUE_BYTE_SIZE_BS + TIMESTAMP_BS + DATA_POINTS_COUNT_BS + SIG_BS\n  uint256 internal constant DATA_PACKAGE_WITHOUT_DATA_POINTS_AND_SIG_BS = 13; // DATA_POINT_VALUE_BYTE_SIZE_BS + TIMESTAMP_BS + DATA_POINTS_COUNT_BS\n  uint256 internal constant REDSTONE_MARKER_BS_PLUS_STANDARD_SLOT_BS = 41; // REDSTONE_MARKER_BS + STANDARD_SLOT_BS\n\n  // Error messages\n  error CalldataOverOrUnderFlow();\n  error IncorrectUnsignedMetadataSize();\n  error InsufficientNumberOfUniqueSigners(uint256 receivedSignersCount, uint256 requiredSignersCount);\n  error EachSignerMustProvideTheSameValue();\n  error EmptyCalldataPointersArr();\n  error InvalidCalldataPointer();\n  error CalldataMustHaveValidPayload();\n  error SignerNotAuthorised(address receivedSigner);\n}\n"
    },
    "@redstone-finance/evm-connector/contracts/core/RedstoneConsumerBase.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity ^0.8.4;\n\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\n\nimport \"./RedstoneConstants.sol\";\nimport \"./RedstoneDefaultsLib.sol\";\nimport \"./CalldataExtractor.sol\";\nimport \"../libs/BitmapLib.sol\";\nimport \"../libs/SignatureLib.sol\";\n\n/**\n * @title The base contract with the main Redstone logic\n * @author The Redstone Oracles team\n * @dev Do not use this contract directly in consumer contracts, take a\n * look at `RedstoneConsumerNumericBase` and `RedstoneConsumerBytesBase` instead\n */\nabstract contract RedstoneConsumerBase is CalldataExtractor {\n  using SafeMath for uint256;\n\n  error GetDataServiceIdNotImplemented();\n\n  /* ========== VIRTUAL FUNCTIONS (MAY BE OVERRIDDEN IN CHILD CONTRACTS) ========== */\n\n  /**\n   * @dev This function must be implemented by the child consumer contract.\n   * It should return dataServiceId which DataServiceWrapper will use if not provided explicitly .\n   * If not overridden, value will always have to be provided explicitly in DataServiceWrapper.\n   * @return dataServiceId being consumed by contract\n   */\n  function getDataServiceId() public view virtual returns (string memory) {\n    revert GetDataServiceIdNotImplemented();\n  }\n\n  /**\n   * @dev This function must be implemented by the child consumer contract.\n   * It should return a unique index for a given signer address if the signer\n   * is authorised, otherwise it should revert\n   * @param receivedSigner The address of a signer, recovered from ECDSA signature\n   * @return Unique index for a signer in the range [0..255]\n   */\n  function getAuthorisedSignerIndex(address receivedSigner) public view virtual returns (uint8);\n\n  /**\n   * @dev This function may be overridden by the child consumer contract.\n   * It should validate the timestamp against the current time (block.timestamp)\n   * It should revert with a helpful message if the timestamp is not valid\n   * @param receivedTimestampMilliseconds Timestamp extracted from calldata\n   */\n  function validateTimestamp(uint256 receivedTimestampMilliseconds) public view virtual {\n    RedstoneDefaultsLib.validateTimestamp(receivedTimestampMilliseconds);\n  }\n\n  /**\n   * @dev This function should be overridden by the child consumer contract.\n   * @return The minimum required value of unique authorised signers\n   */\n  function getUniqueSignersThreshold() public view virtual returns (uint8) {\n    return 1;\n  }\n\n  /**\n   * @dev This function may be overridden by the child consumer contract.\n   * It should aggregate values from different signers to a single uint value.\n   * By default, it calculates the median value\n   * @param values An array of uint256 values from different signers\n   * @return Result of the aggregation in the form of a single number\n   */\n  function aggregateValues(uint256[] memory values) public view virtual returns (uint256) {\n    return RedstoneDefaultsLib.aggregateValues(values);\n  }\n\n  /* ========== FUNCTIONS WITH IMPLEMENTATION (CAN NOT BE OVERRIDDEN) ========== */\n\n  /**\n   * @dev This is an internal helpful function for secure extraction oracle values\n   * from the tx calldata. Security is achieved by signatures verification, timestamp\n   * validation, and aggregating values from different authorised signers into a\n   * single numeric value. If any of the required conditions (e.g. too old timestamp or\n   * insufficient number of authorised signers) do not match, the function will revert.\n   *\n   * Note! You should not call this function in a consumer contract. You can use\n   * `getOracleNumericValuesFromTxMsg` or `getOracleNumericValueFromTxMsg` instead.\n   *\n   * @param dataFeedIds An array of unique data feed identifiers\n   * @return An array of the extracted and verified oracle values in the same order\n   * as they are requested in dataFeedIds array\n   */\n  function _securelyExtractOracleValuesFromTxMsg(bytes32[] memory dataFeedIds)\n    internal\n    view\n    returns (uint256[] memory)\n  {\n    // Initializing helpful variables and allocating memory\n    uint256[] memory uniqueSignerCountForDataFeedIds = new uint256[](dataFeedIds.length);\n    uint256[] memory signersBitmapForDataFeedIds = new uint256[](dataFeedIds.length);\n    uint256[][] memory valuesForDataFeeds = new uint256[][](dataFeedIds.length);\n    for (uint256 i = 0; i < dataFeedIds.length; i++) {\n      // The line below is commented because newly allocated arrays are filled with zeros\n      // But we left it for better readability\n      // signersBitmapForDataFeedIds[i] = 0; // <- setting to an empty bitmap\n      valuesForDataFeeds[i] = new uint256[](getUniqueSignersThreshold());\n    }\n\n    // Extracting the number of data packages from calldata\n    uint256 calldataNegativeOffset = _extractByteSizeOfUnsignedMetadata();\n    uint256 dataPackagesCount = _extractDataPackagesCountFromCalldata(calldataNegativeOffset);\n    calldataNegativeOffset += DATA_PACKAGES_COUNT_BS;\n\n    // Saving current free memory pointer\n    uint256 freeMemPtr;\n    assembly {\n      freeMemPtr := mload(FREE_MEMORY_PTR)\n    }\n\n    // Data packages extraction in a loop\n    for (uint256 dataPackageIndex = 0; dataPackageIndex < dataPackagesCount; dataPackageIndex++) {\n      // Extract data package details and update calldata offset\n      uint256 dataPackageByteSize = _extractDataPackage(\n        dataFeedIds,\n        uniqueSignerCountForDataFeedIds,\n        signersBitmapForDataFeedIds,\n        valuesForDataFeeds,\n        calldataNegativeOffset\n      );\n      calldataNegativeOffset += dataPackageByteSize;\n\n      // Shifting memory pointer back to the \"safe\" value\n      assembly {\n        mstore(FREE_MEMORY_PTR, freeMemPtr)\n      }\n    }\n\n    // Validating numbers of unique signers and calculating aggregated values for each dataFeedId\n    return _getAggregatedValues(valuesForDataFeeds, uniqueSignerCountForDataFeedIds);\n  }\n\n  /**\n   * @dev This is a private helpful function, which extracts data for a data package based\n   * on the given negative calldata offset, verifies them, and in the case of successful\n   * verification updates the corresponding data package values in memory\n   *\n   * @param dataFeedIds an array of unique data feed identifiers\n   * @param uniqueSignerCountForDataFeedIds an array with the numbers of unique signers\n   * for each data feed\n   * @param signersBitmapForDataFeedIds an array of signer bitmaps for data feeds\n   * @param valuesForDataFeeds 2-dimensional array, valuesForDataFeeds[i][j] contains\n   * j-th value for the i-th data feed\n   * @param calldataNegativeOffset negative calldata offset for the given data package\n   *\n   * @return An array of the aggregated values\n   */\n  function _extractDataPackage(\n    bytes32[] memory dataFeedIds,\n    uint256[] memory uniqueSignerCountForDataFeedIds,\n    uint256[] memory signersBitmapForDataFeedIds,\n    uint256[][] memory valuesForDataFeeds,\n    uint256 calldataNegativeOffset\n  ) private view returns (uint256) {\n    uint256 signerIndex;\n\n    (\n      uint256 dataPointsCount,\n      uint256 eachDataPointValueByteSize\n    ) = _extractDataPointsDetailsForDataPackage(calldataNegativeOffset);\n\n    // We use scopes to resolve problem with too deep stack\n    {\n      uint48 extractedTimestamp;\n      address signerAddress;\n      bytes32 signedHash;\n      bytes memory signedMessage;\n      uint256 signedMessageBytesCount;\n\n      signedMessageBytesCount = dataPointsCount.mul(eachDataPointValueByteSize + DATA_POINT_SYMBOL_BS)\n        + DATA_PACKAGE_WITHOUT_DATA_POINTS_AND_SIG_BS; //DATA_POINT_VALUE_BYTE_SIZE_BS + TIMESTAMP_BS + DATA_POINTS_COUNT_BS\n\n      uint256 timestampCalldataOffset = msg.data.length.sub(\n        calldataNegativeOffset + TIMESTAMP_NEGATIVE_OFFSET_IN_DATA_PACKAGE_WITH_STANDARD_SLOT_BS);\n\n      uint256 signedMessageCalldataOffset = msg.data.length.sub(\n        calldataNegativeOffset + SIG_BS + signedMessageBytesCount);\n\n      assembly {\n        // Extracting the signed message\n        signedMessage := extractBytesFromCalldata(\n          signedMessageCalldataOffset,\n          signedMessageBytesCount\n        )\n\n        // Hashing the signed message\n        signedHash := keccak256(add(signedMessage, BYTES_ARR_LEN_VAR_BS), signedMessageBytesCount)\n\n        // Extracting timestamp\n        extractedTimestamp := calldataload(timestampCalldataOffset)\n\n        function initByteArray(bytesCount) -> ptr {\n          ptr := mload(FREE_MEMORY_PTR)\n          mstore(ptr, bytesCount)\n          ptr := add(ptr, BYTES_ARR_LEN_VAR_BS)\n          mstore(FREE_MEMORY_PTR, add(ptr, bytesCount))\n        }\n\n        function extractBytesFromCalldata(offset, bytesCount) -> extractedBytes {\n          let extractedBytesStartPtr := initByteArray(bytesCount)\n          calldatacopy(\n            extractedBytesStartPtr,\n            offset,\n            bytesCount\n          )\n          extractedBytes := sub(extractedBytesStartPtr, BYTES_ARR_LEN_VAR_BS)\n        }\n      }\n\n      // Validating timestamp\n      validateTimestamp(extractedTimestamp);\n\n      // Verifying the off-chain signature against on-chain hashed data\n      signerAddress = SignatureLib.recoverSignerAddress(\n        signedHash,\n        calldataNegativeOffset + SIG_BS\n      );\n      signerIndex = getAuthorisedSignerIndex(signerAddress);\n    }\n\n    // Updating helpful arrays\n    {\n      bytes32 dataPointDataFeedId;\n      uint256 dataPointValue;\n      for (uint256 dataPointIndex = 0; dataPointIndex < dataPointsCount; dataPointIndex++) {\n        // Extracting data feed id and value for the current data point\n        (dataPointDataFeedId, dataPointValue) = _extractDataPointValueAndDataFeedId(\n          calldataNegativeOffset,\n          eachDataPointValueByteSize,\n          dataPointIndex\n        );\n\n        for (\n          uint256 dataFeedIdIndex = 0;\n          dataFeedIdIndex < dataFeedIds.length;\n          dataFeedIdIndex++\n        ) {\n          if (dataPointDataFeedId == dataFeedIds[dataFeedIdIndex]) {\n            uint256 bitmapSignersForDataFeedId = signersBitmapForDataFeedIds[dataFeedIdIndex];\n\n            if (\n              !BitmapLib.getBitFromBitmap(bitmapSignersForDataFeedId, signerIndex) && /* current signer was not counted for current dataFeedId */\n              uniqueSignerCountForDataFeedIds[dataFeedIdIndex] < getUniqueSignersThreshold()\n            ) {\n              // Increase unique signer counter\n              uniqueSignerCountForDataFeedIds[dataFeedIdIndex]++;\n\n              // Add new value\n              valuesForDataFeeds[dataFeedIdIndex][\n                uniqueSignerCountForDataFeedIds[dataFeedIdIndex] - 1\n              ] = dataPointValue;\n\n              // Update signers bitmap\n              signersBitmapForDataFeedIds[dataFeedIdIndex] = BitmapLib.setBitInBitmap(\n                bitmapSignersForDataFeedId,\n                signerIndex\n              );\n            }\n\n            // Breaking, as there couldn't be several indexes for the same feed ID\n            break;\n          }\n        }\n      }\n    }\n\n    // Return total data package byte size\n    return\n      DATA_PACKAGE_WITHOUT_DATA_POINTS_BS +\n      (eachDataPointValueByteSize + DATA_POINT_SYMBOL_BS) *\n      dataPointsCount;\n  }\n\n  /**\n   * @dev This is a private helpful function, which aggregates values from different\n   * authorised signers for the given arrays of values for each data feed\n   *\n   * @param valuesForDataFeeds 2-dimensional array, valuesForDataFeeds[i][j] contains\n   * j-th value for the i-th data feed\n   * @param uniqueSignerCountForDataFeedIds an array with the numbers of unique signers\n   * for each data feed\n   *\n   * @return An array of the aggregated values\n   */\n  function _getAggregatedValues(\n    uint256[][] memory valuesForDataFeeds,\n    uint256[] memory uniqueSignerCountForDataFeedIds\n  ) private view returns (uint256[] memory) {\n    uint256[] memory aggregatedValues = new uint256[](valuesForDataFeeds.length);\n    uint256 uniqueSignersThreshold = getUniqueSignersThreshold();\n\n    for (uint256 dataFeedIndex = 0; dataFeedIndex < valuesForDataFeeds.length; dataFeedIndex++) {\n      if (uniqueSignerCountForDataFeedIds[dataFeedIndex] < uniqueSignersThreshold) {\n        revert InsufficientNumberOfUniqueSigners(\n          uniqueSignerCountForDataFeedIds[dataFeedIndex],\n          uniqueSignersThreshold);\n      }\n      uint256 aggregatedValueForDataFeedId = aggregateValues(valuesForDataFeeds[dataFeedIndex]);\n      aggregatedValues[dataFeedIndex] = aggregatedValueForDataFeedId;\n    }\n\n    return aggregatedValues;\n  }\n}\n"
    },
    "@redstone-finance/evm-connector/contracts/core/RedstoneConsumerNumericBase.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity ^0.8.4;\n\nimport \"./RedstoneConsumerBase.sol\";\n\n/**\n * @title The base contract for Redstone consumers' contracts that allows to\n * securely calculate numeric redstone oracle values\n * @author The Redstone Oracles team\n * @dev This contract can extend other contracts to allow them\n * securely fetch Redstone oracle data from transactions calldata\n */\nabstract contract RedstoneConsumerNumericBase is RedstoneConsumerBase {\n  /**\n   * @dev This function can be used in a consumer contract to securely extract an\n   * oracle value for a given data feed id. Security is achieved by\n   * signatures verification, timestamp validation, and aggregating values\n   * from different authorised signers into a single numeric value. If any of the\n   * required conditions do not match, the function will revert.\n   * Note! This function expects that tx calldata contains redstone payload in the end\n   * Learn more about redstone payload here: https://github.com/redstone-finance/redstone-oracles-monorepo/tree/main/packages/evm-connector#readme\n   * @param dataFeedId bytes32 value that uniquely identifies the data feed\n   * @return Extracted and verified numeric oracle value for the given data feed id\n   */\n  function getOracleNumericValueFromTxMsg(bytes32 dataFeedId)\n    internal\n    view\n    virtual\n    returns (uint256)\n  {\n    bytes32[] memory dataFeedIds = new bytes32[](1);\n    dataFeedIds[0] = dataFeedId;\n    return getOracleNumericValuesFromTxMsg(dataFeedIds)[0];\n  }\n\n  /**\n   * @dev This function can be used in a consumer contract to securely extract several\n   * numeric oracle values for a given array of data feed ids. Security is achieved by\n   * signatures verification, timestamp validation, and aggregating values\n   * from different authorised signers into a single numeric value. If any of the\n   * required conditions do not match, the function will revert.\n   * Note! This function expects that tx calldata contains redstone payload in the end\n   * Learn more about redstone payload here: https://github.com/redstone-finance/redstone-oracles-monorepo/tree/main/packages/evm-connector#readme\n   * @param dataFeedIds An array of unique data feed identifiers\n   * @return An array of the extracted and verified oracle values in the same order\n   * as they are requested in the dataFeedIds array\n   */\n  function getOracleNumericValuesFromTxMsg(bytes32[] memory dataFeedIds)\n    internal\n    view\n    virtual\n    returns (uint256[] memory)\n  {\n    return _securelyExtractOracleValuesFromTxMsg(dataFeedIds);\n  }\n\n  /**\n   * @dev This function works similarly to the `getOracleNumericValuesFromTxMsg` with the\n   * only difference that it allows to request oracle data for an array of data feeds\n   * that may contain duplicates\n   * \n   * @param dataFeedIdsWithDuplicates An array of data feed identifiers (duplicates are allowed)\n   * @return An array of the extracted and verified oracle values in the same order\n   * as they are requested in the dataFeedIdsWithDuplicates array\n   */\n  function getOracleNumericValuesWithDuplicatesFromTxMsg(bytes32[] memory dataFeedIdsWithDuplicates) internal view returns (uint256[] memory) {\n    // Building an array without duplicates\n    bytes32[] memory dataFeedIdsWithoutDuplicates = new bytes32[](dataFeedIdsWithDuplicates.length);\n    bool alreadyIncluded;\n    uint256 uniqueDataFeedIdsCount = 0;\n\n    for (uint256 indexWithDup = 0; indexWithDup < dataFeedIdsWithDuplicates.length; indexWithDup++) {\n      // Checking if current element is already included in `dataFeedIdsWithoutDuplicates`\n      alreadyIncluded = false;\n      for (uint256 indexWithoutDup = 0; indexWithoutDup < uniqueDataFeedIdsCount; indexWithoutDup++) {\n        if (dataFeedIdsWithoutDuplicates[indexWithoutDup] == dataFeedIdsWithDuplicates[indexWithDup]) {\n          alreadyIncluded = true;\n          break;\n        }\n      }\n\n      // Adding if not included\n      if (!alreadyIncluded) {\n        dataFeedIdsWithoutDuplicates[uniqueDataFeedIdsCount] = dataFeedIdsWithDuplicates[indexWithDup];\n        uniqueDataFeedIdsCount++;\n      }\n    }\n\n    // Overriding dataFeedIdsWithoutDuplicates.length\n    // Equivalent to: dataFeedIdsWithoutDuplicates.length = uniqueDataFeedIdsCount;\n    assembly {\n      mstore(dataFeedIdsWithoutDuplicates, uniqueDataFeedIdsCount)\n    }\n\n    // Requesting oracle values (without duplicates)\n    uint256[] memory valuesWithoutDuplicates = getOracleNumericValuesFromTxMsg(dataFeedIdsWithoutDuplicates);\n\n    // Preparing result values array\n    uint256[] memory valuesWithDuplicates = new uint256[](dataFeedIdsWithDuplicates.length);\n    for (uint256 indexWithDup = 0; indexWithDup < dataFeedIdsWithDuplicates.length; indexWithDup++) {\n      for (uint256 indexWithoutDup = 0; indexWithoutDup < dataFeedIdsWithoutDuplicates.length; indexWithoutDup++) {\n        if (dataFeedIdsWithDuplicates[indexWithDup] == dataFeedIdsWithoutDuplicates[indexWithoutDup]) {\n          valuesWithDuplicates[indexWithDup] = valuesWithoutDuplicates[indexWithoutDup];\n          break;\n        }\n      }\n    }\n\n    return valuesWithDuplicates;\n  }\n}\n"
    },
    "@redstone-finance/evm-connector/contracts/core/RedstoneDefaultsLib.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity ^0.8.4;\n\nimport \"../libs/NumericArrayLib.sol\";\n\n/**\n * @title Default implementations of virtual redstone consumer base functions\n * @author The Redstone Oracles team\n */\nlibrary RedstoneDefaultsLib {\n  uint256 constant DEFAULT_MAX_DATA_TIMESTAMP_DELAY_SECONDS = 3 minutes;\n  uint256 constant DEFAULT_MAX_DATA_TIMESTAMP_AHEAD_SECONDS = 1 minutes;\n\n  error TimestampFromTooLongFuture(uint256 receivedTimestampSeconds, uint256 blockTimestamp);\n  error TimestampIsTooOld(uint256 receivedTimestampSeconds, uint256 blockTimestamp);\n\n  function validateTimestamp(uint256 receivedTimestampMilliseconds) internal view {\n    // Getting data timestamp from future seems quite unlikely\n    // But we've already spent too much time with different cases\n    // Where block.timestamp was less than dataPackage.timestamp.\n    // Some blockchains may case this problem as well.\n    // That's why we add MAX_BLOCK_TIMESTAMP_DELAY\n    // and allow data \"from future\" but with a small delay\n    uint256 receivedTimestampSeconds = receivedTimestampMilliseconds / 1000;\n\n    if (block.timestamp < receivedTimestampSeconds) {\n      if ((receivedTimestampSeconds - block.timestamp) > DEFAULT_MAX_DATA_TIMESTAMP_AHEAD_SECONDS) {\n        revert TimestampFromTooLongFuture(receivedTimestampSeconds, block.timestamp);\n      }\n    } else if ((block.timestamp - receivedTimestampSeconds) > DEFAULT_MAX_DATA_TIMESTAMP_DELAY_SECONDS) {\n      revert TimestampIsTooOld(receivedTimestampSeconds, block.timestamp);\n    }\n  }\n\n  function aggregateValues(uint256[] memory values) internal pure returns (uint256) {\n    return NumericArrayLib.pickMedian(values);\n  }\n}\n"
    },
    "@redstone-finance/evm-connector/contracts/libs/BitmapLib.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.4;\n\nlibrary BitmapLib {\n  function setBitInBitmap(uint256 bitmap, uint256 bitIndex) internal pure returns (uint256) {\n    return bitmap | (1 << bitIndex);\n  }\n\n  function getBitFromBitmap(uint256 bitmap, uint256 bitIndex) internal pure returns (bool) {\n    uint256 bitAtIndex = bitmap & (1 << bitIndex);\n    return bitAtIndex > 0;\n  }\n}\n"
    },
    "@redstone-finance/evm-connector/contracts/libs/NumericArrayLib.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.4;\n\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\n\nlibrary NumericArrayLib {\n  // This function sort array in memory using bubble sort algorithm,\n  // which performs even better than quick sort for small arrays\n\n  uint256 constant BYTES_ARR_LEN_VAR_BS = 32;\n  uint256 constant UINT256_VALUE_BS = 32;\n\n  error CanNotPickMedianOfEmptyArray();\n\n  // This function modifies the array\n  function pickMedian(uint256[] memory arr) internal pure returns (uint256) {\n    if (arr.length == 0) {\n      revert CanNotPickMedianOfEmptyArray();\n    }\n    sort(arr);\n    uint256 middleIndex = arr.length / 2;\n    if (arr.length % 2 == 0) {\n      uint256 sum = SafeMath.add(arr[middleIndex - 1], arr[middleIndex]);\n      return sum / 2;\n    } else {\n      return arr[middleIndex];\n    }\n  }\n\n  function sort(uint256[] memory arr) internal pure {\n    assembly {\n      let arrLength := mload(arr)\n      let valuesPtr := add(arr, BYTES_ARR_LEN_VAR_BS)\n      let endPtr := add(valuesPtr, mul(arrLength, UINT256_VALUE_BS))\n      for {\n        let arrIPtr := valuesPtr\n      } lt(arrIPtr, endPtr) {\n        arrIPtr := add(arrIPtr, UINT256_VALUE_BS) // arrIPtr += 32\n      } {\n        for {\n          let arrJPtr := valuesPtr\n        } lt(arrJPtr, arrIPtr) {\n          arrJPtr := add(arrJPtr, UINT256_VALUE_BS) // arrJPtr += 32\n        } {\n          let arrI := mload(arrIPtr)\n          let arrJ := mload(arrJPtr)\n          if lt(arrI, arrJ) {\n            mstore(arrIPtr, arrJ)\n            mstore(arrJPtr, arrI)\n          }\n        }\n      }\n    }\n  }\n}\n"
    },
    "@redstone-finance/evm-connector/contracts/libs/SignatureLib.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.4;\n\nlibrary SignatureLib {\n  uint256 constant ECDSA_SIG_R_BS = 32;\n  uint256 constant ECDSA_SIG_S_BS = 32;\n\n  function recoverSignerAddress(bytes32 signedHash, uint256 signatureCalldataNegativeOffset)\n    internal\n    pure\n    returns (address)\n  {\n    bytes32 r;\n    bytes32 s;\n    uint8 v;\n    assembly {\n      let signatureCalldataStartPos := sub(calldatasize(), signatureCalldataNegativeOffset)\n      r := calldataload(signatureCalldataStartPos)\n      signatureCalldataStartPos := add(signatureCalldataStartPos, ECDSA_SIG_R_BS)\n      s := calldataload(signatureCalldataStartPos)\n      signatureCalldataStartPos := add(signatureCalldataStartPos, ECDSA_SIG_S_BS)\n      v := byte(0, calldataload(signatureCalldataStartPos)) // last byte of the signature memory array\n    }\n    return ecrecover(signedHash, v, r, s);\n  }\n}\n"
    },
    "@redstone-finance/evm-connector/contracts/mocks/AuthorisedMockSignersBase.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.4;\n\nimport \"../core/RedstoneConstants.sol\";\n\nabstract contract AuthorisedMockSignersBase is RedstoneConstants {\n  function getAuthorisedMockSignerIndex(address signerAddress)\n    public\n    view\n    virtual\n    returns (uint8)\n  {\n    return getAllMockExceptLastOneAuthorised(signerAddress);\n  }\n\n  function getAllMockExceptLastOneAuthorised(address signerAddress)\n    public\n    view\n    virtual\n    returns (uint8)\n  {\n    if (signerAddress == 0x8626f6940E2eb28930eFb4CeF49B2d1F2C9C1199) {\n      revert SignerNotAuthorised(signerAddress);\n    } else {\n      return getAllMockAuthorised(signerAddress);\n    }\n  }\n\n  function getAllMockAuthorised(address signerAddress) public view virtual returns (uint8) {\n    // Looks like an array but consumes less gas\n    if (signerAddress == 0xf39Fd6e51aad88F6F4ce6aB8827279cffFb92266) {\n      return 0;\n    } else if (signerAddress == 0x70997970C51812dc3A010C7d01b50e0d17dc79C8) {\n      return 1;\n    } else if (signerAddress == 0x3C44CdDdB6a900fa2b585dd299e03d12FA4293BC) {\n      return 2;\n    } else if (signerAddress == 0x90F79bf6EB2c4f870365E785982E1f101E93b906) {\n      return 3;\n    } else if (signerAddress == 0x15d34AAf54267DB7D7c367839AAf71A00a2C6A65) {\n      return 4;\n    } else if (signerAddress == 0x9965507D1a55bcC2695C58ba16FB37d819B0A4dc) {\n      return 5;\n    } else if (signerAddress == 0x976EA74026E726554dB657fA54763abd0C3a0aa9) {\n      return 6;\n    } else if (signerAddress == 0x14dC79964da2C08b23698B3D3cc7Ca32193d9955) {\n      return 7;\n    } else if (signerAddress == 0x23618e81E3f5cdF7f54C3d65f7FBc0aBf5B21E8f) {\n      return 8;\n    } else if (signerAddress == 0xa0Ee7A142d267C1f36714E4a8F75612F20a79720) {\n      return 9;\n    } else if (signerAddress == 0xBcd4042DE499D14e55001CcbB24a551F3b954096) {\n      return 10;\n    } else if (signerAddress == 0x71bE63f3384f5fb98995898A86B02Fb2426c5788) {\n      return 11;\n    } else if (signerAddress == 0xFABB0ac9d68B0B445fB7357272Ff202C5651694a) {\n      return 12;\n    } else if (signerAddress == 0x1CBd3b2770909D4e10f157cABC84C7264073C9Ec) {\n      return 13;\n    } else if (signerAddress == 0xdF3e18d64BC6A983f673Ab319CCaE4f1a57C7097) {\n      return 14;\n    } else if (signerAddress == 0xcd3B766CCDd6AE721141F452C550Ca635964ce71) {\n      return 15;\n    } else if (signerAddress == 0x2546BcD3c84621e976D8185a91A922aE77ECEc30) {\n      return 16;\n    } else if (signerAddress == 0xbDA5747bFD65F08deb54cb465eB87D40e51B197E) {\n      return 17;\n    } else if (signerAddress == 0xdD2FD4581271e230360230F9337D5c0430Bf44C0) {\n      return 18;\n    } else if (signerAddress == 0x8626f6940E2eb28930eFb4CeF49B2d1F2C9C1199) {\n      return 19;\n    } else {\n      revert SignerNotAuthorised(signerAddress);\n    }\n  }\n}\n"
    },
    "contracts/adapters/RedstonePriceFeedGBP.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.23;\n\nimport \"../RedStoneBaseContracts/redstone-oracles-monorepo/packages/on-chain-relayer/contracts/price-feeds/without-rounds/MergedPriceFeedAdapterWithoutRounds.sol\";\n\ncontract RedstonePriceFeedGBP is MergedPriceFeedAdapterWithoutRounds {\n    bytes32 private constant GBP_ID = bytes32(\"GBP\");\n\n    error UpdaterNotAuthorised(address signer);\n\n    // By default, we have 3 seconds between the updates, but in the REya Use Case\n    // We need to set it to 0 to avoid conflicts between users\n    function getMinIntervalBetweenUpdates()\n        public\n        view\n        virtual\n        override\n        returns (uint256)\n    {\n        return 0;\n    }\n\n    function getDataFeedId() public pure override returns (bytes32) {\n        return GBP_ID;\n    }\n\n    function getDataServiceId() public pure override returns (string memory) {\n        return \"redstone-primary-prod\";\n    }\n\n    function getUniqueSignersThreshold() public pure override returns (uint8) {\n        return 3;\n    }\n\n    function getAuthorisedSignerIndex(\n        address signerAddress\n    ) public view virtual override returns (uint8) {\n        if (signerAddress == 0x8BB8F32Df04c8b654987DAaeD53D6B6091e3B774) {\n            return 0;\n        } else if (\n            signerAddress == 0xdEB22f54738d54976C4c0fe5ce6d408E40d88499\n        ) {\n            return 1;\n        } else if (\n            signerAddress == 0x51Ce04Be4b3E32572C4Ec9135221d0691Ba7d202\n        ) {\n            return 2;\n        } else if (\n            signerAddress == 0xDD682daEC5A90dD295d14DA4b0bec9281017b5bE\n        ) {\n            return 3;\n        } else if (\n            signerAddress == 0x9c5AE89C4Af6aA32cE58588DBaF90d18a855B6de\n        ) {\n            return 4;\n        } else {\n            revert SignerNotAuthorised(signerAddress);\n        }\n    }\n}\n"
    },
    "contracts/adapters/RedstonePriceFeedXAU.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.23;\n\nimport \"../RedStoneBaseContracts/redstone-oracles-monorepo/packages/on-chain-relayer/contracts/price-feeds/without-rounds/MergedPriceFeedAdapterWithoutRounds.sol\";\n\ncontract RedstonePriceFeedXAU is MergedPriceFeedAdapterWithoutRounds {\n    bytes32 private constant XAU_ID = bytes32(\"XAU\");\n\n    error UpdaterNotAuthorised(address signer);\n\n    // By default, we have 3 seconds between the updates, but in the REya Use Case\n    // We need to set it to 0 to avoid conflicts between users\n    function getMinIntervalBetweenUpdates()\n        public\n        view\n        virtual\n        override\n        returns (uint256)\n    {\n        return 0;\n    }\n\n    function getDataFeedId() public pure override returns (bytes32) {\n        return XAU_ID;\n    }\n\n    function getDataServiceId() public pure override returns (string memory) {\n        return \"redstone-primary-prod\";\n    }\n\n    function getUniqueSignersThreshold() public pure override returns (uint8) {\n        return 3;\n    }\n\n    function getAuthorisedSignerIndex(\n        address signerAddress\n    ) public view virtual override returns (uint8) {\n        if (signerAddress == 0x8BB8F32Df04c8b654987DAaeD53D6B6091e3B774) {\n            return 0;\n        } else if (\n            signerAddress == 0xdEB22f54738d54976C4c0fe5ce6d408E40d88499\n        ) {\n            return 1;\n        } else if (\n            signerAddress == 0x51Ce04Be4b3E32572C4Ec9135221d0691Ba7d202\n        ) {\n            return 2;\n        } else if (\n            signerAddress == 0xDD682daEC5A90dD295d14DA4b0bec9281017b5bE\n        ) {\n            return 3;\n        } else if (\n            signerAddress == 0x9c5AE89C4Af6aA32cE58588DBaF90d18a855B6de\n        ) {\n            return 4;\n        } else {\n            revert SignerNotAuthorised(signerAddress);\n        }\n    }\n}\n"
    },
    "contracts/RedStoneBaseContracts/redstone-oracles-monorepo/packages/on-chain-relayer/contracts/benchmarks/PriceFeedsAdapterWithoutRoundsBenchmark.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity ^0.8.14;\n\nimport {PriceFeedsAdapterWithoutRoundsMock} from \"../mocks/PriceFeedsAdapterWithoutRoundsMock.sol\";\n\ncontract PriceFeedsAdapterWithoutRoundsBenchmark is PriceFeedsAdapterWithoutRoundsMock {\n  function getAllowedTimestampDiffsInSeconds() public pure override returns (uint256 maxDataAheadSeconds, uint256 maxDataDelaySeconds) {\n    maxDataAheadSeconds = 20 minutes;\n    maxDataDelaySeconds = 20 minutes;\n  }\n}\n"
    },
    "contracts/RedStoneBaseContracts/redstone-oracles-monorepo/packages/on-chain-relayer/contracts/benchmarks/PriceFeedsAdapterWithRoundsBenchmark.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity ^0.8.14;\n\nimport {PriceFeedsAdapterWithRoundsMock} from \"../mocks/PriceFeedsAdapterWithRoundsMock.sol\";\n\ncontract PriceFeedsAdapterWithRoundsBenchmark is PriceFeedsAdapterWithRoundsMock {\n  function getAllowedTimestampDiffsInSeconds() public pure override returns (uint256 maxDataAheadSeconds, uint256 maxDataDelaySeconds) {\n    maxDataAheadSeconds = 20 minutes;\n    maxDataDelaySeconds = 20 minutes;\n  }\n}\n"
    },
    "contracts/RedStoneBaseContracts/redstone-oracles-monorepo/packages/on-chain-relayer/contracts/benchmarks/ReadBenchmark.sol": {
      "content": "// SPDX-License-Identifier: MIT \nimport {PriceFeedsAdapterWithLowestGasRead} from \"../mocks/PriceFeedsAdapterWithLowestRead.sol\";\n\npragma solidity ^0.8.14;\n\ncontract ReadBenchmark {\n\n    event Value(uint256);\n\n    uint256 counter = 100;\n    PriceFeedsAdapterWithLowestGasRead readFrom;\n    address rawAddress;\n\n    bytes constant getBtcValueWithLowestGasSig = abi.encodeWithSignature(\"getBtcValueWithLowestGas()\");\n    address immutable IMMUTABLE_ADDRESS = 0xCf7Ed3AccA5a467e9e704C703E8D87F634fB0Fc9;\n    bytes4 constant SIG = 0xc505f591;\n\n    constructor(address _readFrom) {\n        readFrom = PriceFeedsAdapterWithLowestGasRead(_readFrom);\n        rawAddress = _readFrom;\n        assembly {\n            sstore(0xf497211eccb68cc78a757a9caed87152a70e6da38b5f59e20a3feb628cda40b8, 0x64) \n        }\n    }\n\n    function getBtcValueWithLowestGas() external  returns (uint256) {\n        return readFrom.getBtcValueWithLowestGas();\n    }\n    \n    function stdReadUnsafe() external returns (uint256) {\n        return readFrom.getValueForDataFeedUnsafe(bytes32(\"BTC\"));\n}\n\n    function readFromStateWithoutCall() external returns (uint256) {\n        return counter;\n    }\n\n    function readFromStateWithoutCallAssembly() external returns (uint256 dataFeedValue) {\n        assembly {\n          dataFeedValue := sload(0xf497211eccb68cc78a757a9caed87152a70e6da38b5f59e20a3feb628cda40b8) \n        }\n    }\n\n    function readUsingStaticCall() external returns (uint256) {\n        (, bytes memory data) = rawAddress.staticcall(getBtcValueWithLowestGasSig);\n    }\n\n    function readUsingStaticCallAssembly() external returns (uint256) {\n        uint256 value;\n        \n        assembly {\t\n            let freeSlot := mload(0x40)\t\n            \n            mstore(freeSlot, SIG)\n\n            let success := staticcall(\t\n                5000, // estimated gas cost for this function\t\n                0xCf7Ed3AccA5a467e9e704C703E8D87F634fB0Fc9,\t\n                freeSlot,\t\n                0x04,\n                freeSlot,\t\n                0x20\t\n            )\n            // we don't have to handle error, cause underlying function never fails\n\n            value := mload(freeSlot)\t  \n        }\n\n        return value;\n    }\n\n    function readUsingStaticCallAssemblyWithErrorHandling() external returns (uint256) {\n        uint256 value;\n        \n        assembly {\t\n            let freeSlot := mload(0x40)\t\n            \n            mstore(freeSlot, SIG)\n\n            let success := staticcall(\t\n                5000, // estimated gas cost for this function\t\n                0xCf7Ed3AccA5a467e9e704C703E8D87F634fB0Fc9,\t\n                freeSlot,\t\n                0x04,\n                freeSlot,\t\n                0x20\t\n            )\n\n            switch success\t    \n            case 0 {\t   \n              revert(freeSlot, 0x40) \n            }\n            default {\n                value := mload(freeSlot)\n            }\n           \n        }\n        \n        return value;\n    }\n\n    function readUsingStaticCallAssemblyWithErrorHandlingWithImmutable() external returns (uint256) {\n        uint256 value;\n        address tempAddress = IMMUTABLE_ADDRESS;\n        assembly {\t\n            let freeSlot := mload(0x40)\t\n            \n            mstore(freeSlot, SIG)\n\n            let success := staticcall(\t\n                5000, // estimated gas cost for this function\t\n                tempAddress,\t\n                freeSlot,\t\n                0x04,\n                freeSlot,\t\n                0x20\t\n            )\n\n            switch success\t    \n            case 0 {\t   \n              revert(freeSlot, 0x40) \n            }\n            default {\n                value := mload(freeSlot)\n            }\n           \n        }\n        \n        return value;\n    }\n\n    function readUsingCallAssemblyWithErrorHandling() external returns (uint256) {\n        uint256 value;\n        \n        assembly {\t\n            let freeSlot := mload(0x40)\t\n            \n            mstore(freeSlot, SIG)\n\n            let success := call(\t\n                5000, // estimated gas cost for this function\t\n                0xCf7Ed3AccA5a467e9e704C703E8D87F634fB0Fc9,\t\n                0, // value to send\n                freeSlot,\t\n                0x04,\n                freeSlot,\t\n                0x20\t\n            )\n            // we don't have to handle error, cause underlying function never fails\n\n            switch success\t    \n            case 0 {\t   \n              revert(freeSlot, 0x40) \n            }\n            default {\n                value := mload(freeSlot)\n            }\n            \n        }\n\n        return value;\n    }\n\n    function readUsingDelegateCallAssemblyWithErrorHandling() external returns (uint256) {\n        uint256 value;\n        \n        assembly {\t\n            let freeSlot := mload(0x40)\t\n            \n            mstore(freeSlot, SIG)\n\n            let success := delegatecall(\t\n                5000, // estimated gas cost for this function\t\n                0xCf7Ed3AccA5a467e9e704C703E8D87F634fB0Fc9,\t\n                freeSlot,\t\n                0x04,\n                freeSlot,\t\n                0x20\t\n            )\n\n            switch success\t    \n            case 0 {\t   \n              revert(freeSlot, 0x40) \n            }\n            default {\n                value := mload(freeSlot)\n            }\n           \n        }\n        \n        return value;\n    }\n\n    function readUsingCall() external returns (uint256) {\n        (, bytes memory data) = rawAddress.call(getBtcValueWithLowestGasSig);\n    }\n\n}\n\ncontract Hopper {\n    Hopper hopTo;\n    bool lastHooper;\n\n    constructor(address _hopTo, bool _lastHooper) {\n        hopTo = Hopper(_hopTo);\n        lastHooper = _lastHooper;\n    }\n\n    function nextHop() external {\n        if(lastHooper == false) {\n            Hopper(hopTo).nextHop();\n        }\n    }\n\n}"
    },
    "contracts/RedStoneBaseContracts/redstone-oracles-monorepo/packages/on-chain-relayer/contracts/benchmarks/SinglePriceFeedAdapterBenchmark.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity ^0.8.14;\n\nimport {SinglePriceFeedAdapterMock} from \"../mocks/SinglePriceFeedAdapterMock.sol\";\n\ncontract SinglePriceFeedAdapterBenchmark is SinglePriceFeedAdapterMock {\n  function getAllowedTimestampDiffsInSeconds() public pure override returns (uint256 maxDataAheadSeconds, uint256 maxDataDelaySeconds) {\n    maxDataAheadSeconds = 20 minutes;\n    maxDataDelaySeconds = 20 minutes;\n  }\n}\n"
    },
    "contracts/RedStoneBaseContracts/redstone-oracles-monorepo/packages/on-chain-relayer/contracts/benchmarks/SinglePriceFeedAdapterWithClearingBenchmark.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity ^0.8.14;\n\nimport {SinglePriceFeedAdapterWithClearingMock} from \"../mocks/SinglePriceFeedAdapterWithClearingMock.sol\";\n\ncontract SinglePriceFeedAdapterWithClearingBenchmark is SinglePriceFeedAdapterWithClearingMock {\n  function getAllowedTimestampDiffsInSeconds() public pure override returns (uint256 maxDataAheadSeconds, uint256 maxDataDelaySeconds) {\n    maxDataAheadSeconds = 20 minutes;\n    maxDataDelaySeconds = 20 minutes;\n  }\n}\n"
    },
    "contracts/RedStoneBaseContracts/redstone-oracles-monorepo/packages/on-chain-relayer/contracts/core/IRedstoneAdapter.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity ^0.8.14;\n\n/**\n * @title Interface of RedStone adapter\n * @author The Redstone Oracles team\n */\ninterface IRedstoneAdapter {\n\n  /**\n   * @notice Updates values of all data feeds supported by the Adapter contract\n   * @dev This function requires an attached redstone payload to the transaction calldata.\n   * It also requires each data package to have exactly the same timestamp\n   * @param dataPackagesTimestamp Timestamp of each signed data package in the redstone payload\n   */\n  function updateDataFeedsValues(uint256 dataPackagesTimestamp) external;\n\n\n  /**\n   * @notice Returns the latest properly reported value of the data feed\n   * @param dataFeedId The identifier of the requested data feed\n   * @return value The latest value of the given data feed\n   */\n  function getValueForDataFeed(bytes32 dataFeedId) external view returns (uint256);\n\n  /**\n   * @notice Returns the latest properly reported values for several data feeds\n   * @param requestedDataFeedIds The array of identifiers for the requested feeds\n   * @return values Values of the requested data feeds in the corresponding order\n   */\n  function getValuesForDataFeeds(bytes32[] memory requestedDataFeedIds) external view returns (uint256[] memory);\n\n  /**\n   * @notice Returns data timestamp from the latest update\n   * @dev It's virtual, because its implementation can sometimes be different\n   * (e.g. SinglePriceFeedAdapterWithClearing)\n   * @return lastDataTimestamp Timestamp of the latest reported data packages\n   */\n  function getDataTimestampFromLatestUpdate() external view returns (uint256 lastDataTimestamp);\n\n  /**\n   * @notice Returns block timestamp of the latest successful update\n   * @return blockTimestamp The block timestamp of the latest successful update\n   */\n  function getBlockTimestampFromLatestUpdate() external view returns (uint256 blockTimestamp);\n\n\n  /**\n   * @notice Returns timestamps of the latest successful update\n   * @return dataTimestamp timestamp (usually in milliseconds) from the signed data packages\n   * @return blockTimestamp timestamp of the block when the update has happened\n   */\n  function getTimestampsFromLatestUpdate() external view returns (uint128 dataTimestamp, uint128 blockTimestamp);\n\n  /**\n   * @notice Returns identifiers of all data feeds supported by the Adapter contract\n   * @return An array of data feed identifiers\n   */\n  function getDataFeedIds() external view returns (bytes32[] memory);\n\n  /**\n   * @notice Returns the unique index of the given data feed\n   * @param dataFeedId The data feed identifier\n   * @return index The index of the data feed\n   */\n  function getDataFeedIndex(bytes32 dataFeedId) external view returns (uint256);\n\n  /**\n   * @notice Returns maximalrequired interval (usually in seconds) between subsequent updates\n   * @return interval The max required interval between updates\n   */\n  function getMaxIntervalBetweenUpdates() external view returns (uint256);\n\n   /**\n   * @notice Returns minimal required interval (usually in seconds) between subsequent updates\n   * @return interval The required interval between updates\n   */\n  function getMinIntervalBetweenUpdates() external view returns (uint256);\n\n  /**\n   * @notice Reverts if the proposed timestamp of data packages it too old or too new\n   * comparing to the block.timestamp. It also ensures that the proposed timestamp is newer\n   * Then the one from the previous update\n   * @param dataPackagesTimestamp The proposed timestamp (usually in milliseconds)\n   */\n  function validateProposedDataPackagesTimestamp(uint256 dataPackagesTimestamp) external view;\n\n  /**\n   * @notice Reverts if the updater is not authorised\n   * @dev This function should revert if msg.sender is not allowed to update data feed values\n   * @param updater The address of the proposed updater\n   */\n  function requireAuthorisedUpdater(address updater) external view;\n}\n"
    },
    "contracts/RedStoneBaseContracts/redstone-oracles-monorepo/packages/on-chain-relayer/contracts/core/RedstoneAdapterBase.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity ^0.8.14;\n\nimport {RedstoneConsumerNumericBase, RedstoneDefaultsLib} from \"@redstone-finance/evm-connector/contracts/core/RedstoneConsumerNumericBase.sol\";\nimport {IRedstoneAdapter} from \"./IRedstoneAdapter.sol\";\n\n/**\n * @title Core logic of Redstone Adapter Contract\n * @author The Redstone Oracles team\n * @dev This contract is used to repeatedly push Redstone data to blockchain storage\n * More details here: https://docs.redstone.finance/docs/smart-contract-devs/get-started/redstone-classic\n *\n * Key details about the contract:\n * - Values for data feeds can be updated using the `updateDataFeedsValues` function\n * - All data feeds must be updated within a single call, partial updates are not allowed\n * - There is a configurable minimum interval between updates\n * - Updaters can be restricted by overriding `requireAuthorisedUpdater` function\n * - The contract is designed to force values validation, by default it prevents returning zero values\n * - All data packages in redstone payload must have the same timestamp,\n *    equal to `dataPackagesTimestamp` argument of the `updateDataFeedsValues` function\n * - Block timestamp abstraction - even though we call it blockTimestamp in many places,\n *    it's possible to have a custom logic here, e.g. use block number instead of a timestamp\n */\nabstract contract RedstoneAdapterBase is RedstoneConsumerNumericBase, IRedstoneAdapter {\n  // We don't use storage variables to avoid potential problems with upgradable contracts\n  bytes32 internal constant LATEST_UPDATE_TIMESTAMPS_STORAGE_LOCATION = 0x3d01e4d77237ea0f771f1786da4d4ff757fcba6a92933aa53b1dcef2d6bd6fe2; // keccak256(\"RedStone.lastUpdateTimestamp\");\n  uint256 internal constant MIN_INTERVAL_BETWEEN_UPDATES = 3 seconds;\n  uint256 internal constant MAX_INTERVAL_BETWEEN_UPDATES = 1 days;\n  uint256 internal constant BITS_COUNT_IN_16_BYTES = 128;\n  uint256 internal constant MAX_NUMBER_FOR_128_BITS = 0x00000000000000000000000000000000ffffffffffffffffffffffffffffffff;\n\n  error DataTimestampShouldBeNewerThanBefore(\n    uint256 receivedDataTimestampMilliseconds,\n    uint256 lastDataTimestampMilliseconds\n  );\n\n  error MinIntervalBetweenUpdatesHasNotPassedYet(\n    uint256 currentBlockTimestamp,\n    uint256 lastUpdateTimestamp,\n    uint256 minIntervalBetweenUpdates\n  );\n\n  error MaxIntervalBetweenUpdatesHasPassedYet(\n    uint256 currentBlockTimestamp,\n    uint256 lastUpdateTimestamp,\n    uint256 maxIntervalBetweenUpdates\n  );\n\n  error DataPackageTimestampMismatch(uint256 expectedDataTimestamp, uint256 dataPackageTimestamp);\n\n  error DataFeedValueCannotBeZero(bytes32 dataFeedId);\n\n  error DataFeedIdNotFound(bytes32 dataFeedId);\n\n  error DataTimestampIsTooBig(uint256 dataTimestamp);\n\n  error BlockTimestampIsTooBig(uint256 blockTimestamp);\n\n  /**\n   * @notice Reverts if the updater is not authorised\n   * @dev This function should revert if msg.sender is not allowed to update data feed values\n   * @param updater The address of the proposed updater\n   */\n  function requireAuthorisedUpdater(address updater) public view virtual {\n    // By default, anyone can update data feed values, but it can be overridden\n  }\n\n  /**\n   * @notice Returns identifiers of all data feeds supported by the Adapter contract\n   * @dev this function must be implemented in derived contracts\n   * @return An array of data feed identifiers\n   */\n  function getDataFeedIds() public view virtual returns (bytes32[] memory);\n\n  /**\n   * @notice Returns the unique index of the given data feed\n   * @dev This function can (and should) be overriden to reduce gas\n   * costs of other functions\n   * @param dataFeedId The data feed identifier\n   * @return index The index of the data feed\n   */\n  function getDataFeedIndex(bytes32 dataFeedId) public view virtual returns (uint256) {\n    bytes32[] memory dataFeedIds = getDataFeedIds();\n    for (uint256 i = 0; i < dataFeedIds.length;) {\n      if (dataFeedIds[i] == dataFeedId) {\n        return i;\n      }\n      unchecked { i++; } // reduces gas costs\n    }\n    revert DataFeedIdNotFound(dataFeedId);\n  }\n\n  /**\n   * @notice Updates values of all data feeds supported by the Adapter contract\n   * @dev This function requires an attached redstone payload to the transaction calldata.\n   * It also requires each data package to have exactly the same timestamp\n   * @param dataPackagesTimestamp Timestamp of each signed data package in the redstone payload\n   */\n  function updateDataFeedsValues(uint256 dataPackagesTimestamp) public {\n    requireAuthorisedUpdater(msg.sender);\n    _assertMinIntervalBetweenUpdatesPassed();\n    _assertMaxIntervalBetweenUpdatesPassed();\n     validateProposedDataPackagesTimestamp(dataPackagesTimestamp);\n    _saveTimestampsOfCurrentUpdate(dataPackagesTimestamp);\n\n    bytes32[] memory dataFeedsIdsArray = getDataFeedIds();\n\n    // It will trigger timestamp validation for each data package\n    uint256[] memory oracleValues = getOracleNumericValuesFromTxMsg(dataFeedsIdsArray);\n\n    _validateAndUpdateDataFeedsValues(dataFeedsIdsArray, oracleValues);\n  }\n\n  /**\n   * @dev Note! This function is not called directly, it's called for each data package    .\n   * in redstone payload and just verifies if each data package has the same timestamp\n   * as the one that was saved in the storage\n   * @param receivedTimestampMilliseconds Timestamp from a data package\n   */\n  function validateTimestamp(uint256 receivedTimestampMilliseconds) public view virtual override {\n    // It means that we are in the special view context and we can skip validation of the\n    // timestamp. It can be useful for calling view functions, as they can not modify the contract\n    // state to pass the timestamp validation below\n    if (msg.sender == address(0)) {\n      return;\n    }\n\n    uint256 expectedDataPackageTimestamp = getDataTimestampFromLatestUpdate();\n    if (receivedTimestampMilliseconds != expectedDataPackageTimestamp) {\n      revert DataPackageTimestampMismatch(\n        expectedDataPackageTimestamp,\n        receivedTimestampMilliseconds\n      );\n    }\n  }\n\n  /**\n   * @dev This function should be implemented by the actual contract\n   * and should contain the logic of values validation and reporting.\n   * Usually, values reporting is based on saving them to the contract storage,\n   * e.g. in PriceFeedsAdapter, but some custom implementations (e.g. GMX keeper adapter\n   * or Mento Sorted Oracles adapter) may handle values updating in a different way\n   * @param dataFeedIdsArray Array of the data feeds identifiers (it will always be all data feed ids)\n   * @param values The reported values that should be validated and reported\n   */\n  function _validateAndUpdateDataFeedsValues(bytes32[] memory dataFeedIdsArray, uint256[] memory values) internal virtual;\n\n\n function  _assertMaxIntervalBetweenUpdatesPassed() private view {\n    uint256 currentBlockTimestamp = getBlockTimestamp();\n    uint256 blockTimestampFromLatestUpdate = getBlockTimestampFromLatestUpdate();\n    uint256 maxIntervalBetweenUpdates = getMaxIntervalBetweenUpdates();\n    if (currentBlockTimestamp > blockTimestampFromLatestUpdate + maxIntervalBetweenUpdates && blockTimestampFromLatestUpdate > 0) {\n      revert MaxIntervalBetweenUpdatesHasPassedYet(\n        currentBlockTimestamp,\n        blockTimestampFromLatestUpdate,\n        maxIntervalBetweenUpdates\n      );\n    }\n  }\n  /**\n   * @dev This function reverts if not enough time passed since the latest update\n   */\n  function _assertMinIntervalBetweenUpdatesPassed() private view {\n    uint256 currentBlockTimestamp = getBlockTimestamp();\n    uint256 blockTimestampFromLatestUpdate = getBlockTimestampFromLatestUpdate();\n    uint256 minIntervalBetweenUpdates = getMinIntervalBetweenUpdates();\n    if (currentBlockTimestamp < blockTimestampFromLatestUpdate + minIntervalBetweenUpdates) {\n      revert MinIntervalBetweenUpdatesHasNotPassedYet(\n        currentBlockTimestamp,\n        blockTimestampFromLatestUpdate,\n        minIntervalBetweenUpdates\n      );\n    }\n  }\n\n  /**\n   * @notice Returns minimal required interval (usually in seconds) between subsequent updates\n   * @dev You can override this function to change the required interval between udpates.\n   * Please do not set it to 0, as it may open many attack vectors\n   * @return interval The required interval between updates\n   */\n  function getMinIntervalBetweenUpdates() public view virtual returns (uint256) {\n    return MIN_INTERVAL_BETWEEN_UPDATES;\n  }\n\n  /**\n   * @notice Returns max required interval (usually in seconds) between subsequent updates\n   * @dev You can override this function to change the required interval between udpates.\n   * @return interval The required interval between updates\n   */\n  function getMaxIntervalBetweenUpdates() public view virtual returns (uint256) {\n    return MAX_INTERVAL_BETWEEN_UPDATES;\n  }\n\n\n\n\n\n  /**\n   * @notice Reverts if the proposed timestamp of data packages it too old or too new\n   * comparing to the block.timestamp. It also ensures that the proposed timestamp is newer\n   * Then the one from the previous update\n   * @param dataPackagesTimestamp The proposed timestamp (usually in milliseconds)\n   */\n  function validateProposedDataPackagesTimestamp(uint256 dataPackagesTimestamp) public view {\n    _preventUpdateWithOlderDataPackages(dataPackagesTimestamp);\n    validateDataPackagesTimestampOnce(dataPackagesTimestamp);\n  }\n\n\n  /**\n   * @notice Reverts if the proposed timestamp of data packages it too old or too new\n   * comparing to the current block timestamp\n   * @param dataPackagesTimestamp The proposed timestamp (usually in milliseconds)\n   */\n  function validateDataPackagesTimestampOnce(uint256 dataPackagesTimestamp) public view virtual {\n    uint256 receivedTimestampSeconds = dataPackagesTimestamp / 1000;\n\n    (uint256 maxDataAheadSeconds, uint256 maxDataDelaySeconds) = getAllowedTimestampDiffsInSeconds();\n\n    uint256 blockTimestamp = getBlockTimestamp();\n\n    if (blockTimestamp < receivedTimestampSeconds) {\n      if ((receivedTimestampSeconds - blockTimestamp) > maxDataAheadSeconds) {\n        revert RedstoneDefaultsLib.TimestampFromTooLongFuture(receivedTimestampSeconds, blockTimestamp);\n      }\n    } else if ((blockTimestamp - receivedTimestampSeconds) > maxDataDelaySeconds) {\n      revert RedstoneDefaultsLib.TimestampIsTooOld(receivedTimestampSeconds, blockTimestamp);\n    }\n  }\n\n  /**\n   * @dev This function can be overriden, e.g. to use block.number instead of block.timestamp\n   * It can be useful in some L2 chains, as sometimes their different blocks can have the same timestamp\n   * @return timestamp Timestamp or Block number or any other number that can identify time in the context\n   * of the given blockchain\n   */\n  function getBlockTimestamp() public view virtual returns (uint256) {\n    return block.timestamp;\n  }\n\n  /**\n   * @dev Helpful function for getting values for timestamp validation\n   * @return  maxDataAheadSeconds Max allowed number of seconds ahead of block.timrstamp\n   * @return  maxDataDelaySeconds Max allowed number of seconds for data delay\n   */\n  function getAllowedTimestampDiffsInSeconds() public view virtual returns (uint256 maxDataAheadSeconds, uint256 maxDataDelaySeconds) {\n    maxDataAheadSeconds = RedstoneDefaultsLib.DEFAULT_MAX_DATA_TIMESTAMP_AHEAD_SECONDS;\n    maxDataDelaySeconds = RedstoneDefaultsLib.DEFAULT_MAX_DATA_TIMESTAMP_DELAY_SECONDS;\n  }\n\n  /**\n   * @dev Reverts if proposed data packages are not newer than the ones used previously\n   * @param dataPackagesTimestamp Timestamp od the data packages (usually in milliseconds)\n   */\n  function _preventUpdateWithOlderDataPackages(uint256 dataPackagesTimestamp) internal view {\n    uint256 dataTimestampFromLatestUpdate = getDataTimestampFromLatestUpdate();\n\n    if (dataPackagesTimestamp <= dataTimestampFromLatestUpdate) {\n      revert DataTimestampShouldBeNewerThanBefore(\n        dataPackagesTimestamp,\n        dataTimestampFromLatestUpdate\n      );\n    }\n  }\n\n  /**\n   * @notice Returns data timestamp from the latest update\n   * @dev It's virtual, because its implementation can sometimes be different\n   * (e.g. SinglePriceFeedAdapterWithClearing)\n   * @return lastDataTimestamp Timestamp of the latest reported data packages\n   */\n  function getDataTimestampFromLatestUpdate() public view virtual returns (uint256 lastDataTimestamp) {\n    (lastDataTimestamp, ) = getTimestampsFromLatestUpdate();\n  }\n\n  /**\n   * @notice Returns block timestamp of the latest successful update\n   * @return blockTimestamp The block timestamp of the latest successful update\n   */\n  function getBlockTimestampFromLatestUpdate() public view returns (uint256 blockTimestamp) {\n    (, blockTimestamp) = getTimestampsFromLatestUpdate();\n  }\n\n  /**\n   * @dev Returns 2 timestamps packed into a single uint256 number\n   * @return packedTimestamps a single uin256 number with 2 timestamps\n   */\n  function getPackedTimestampsFromLatestUpdate() public view returns (uint256 packedTimestamps) {\n    assembly {\n      packedTimestamps := sload(LATEST_UPDATE_TIMESTAMPS_STORAGE_LOCATION)\n    }\n  }\n\n  /**\n   * @notice Returns timestamps of the latest successful update\n   * @return dataTimestamp timestamp (usually in milliseconds) from the signed data packages\n   * @return blockTimestamp timestamp of the block when the update has happened\n   */\n  function getTimestampsFromLatestUpdate() public view virtual returns (uint128 dataTimestamp, uint128 blockTimestamp) {\n    return _unpackTimestamps(getPackedTimestampsFromLatestUpdate());\n  }\n\n\n  /**\n   * @dev A helpful function to unpack 2 timestamps from one uin256 number\n   * @param packedTimestamps a single uin256 number\n   * @return dataTimestamp fetched from left 128 bits\n   * @return blockTimestamp fetched from right 128 bits\n   */\n  function _unpackTimestamps(uint256 packedTimestamps) internal pure returns (uint128 dataTimestamp, uint128 blockTimestamp) {\n    dataTimestamp = uint128(packedTimestamps >> 128); // left 128 bits\n    blockTimestamp = uint128(packedTimestamps); // right 128 bits\n  }\n\n\n  /**\n   * @dev Logic of saving timestamps of the current update\n   * By default, it stores packed timestamps in one storage slot (32 bytes)\n   * to minimise gas costs\n   * But it can be overriden (e.g. in SinglePriceFeedAdapter)\n   * @param   dataPackagesTimestamp  .\n   */\n  function _saveTimestampsOfCurrentUpdate(uint256 dataPackagesTimestamp) internal virtual {\n    uint256 blockTimestamp = getBlockTimestamp();\n\n    if (blockTimestamp > MAX_NUMBER_FOR_128_BITS) {\n      revert BlockTimestampIsTooBig(blockTimestamp);\n    }\n\n    if (dataPackagesTimestamp > MAX_NUMBER_FOR_128_BITS) {\n      revert DataTimestampIsTooBig(dataPackagesTimestamp);\n    }\n\n    assembly {\n      let timestamps := or(shl(BITS_COUNT_IN_16_BYTES, dataPackagesTimestamp), blockTimestamp)\n      sstore(LATEST_UPDATE_TIMESTAMPS_STORAGE_LOCATION, timestamps)\n    }\n  }\n\n  /**\n   * @notice Returns the latest properly reported value of the data feed\n   * @param dataFeedId The identifier of the requested data feed\n   * @return value The latest value of the given data feed\n   */\n  function getValueForDataFeed(bytes32 dataFeedId) public view returns (uint256) {\n    getDataFeedIndex(dataFeedId); // will revert if data feed id is not supported\n\n    // \"unsafe\" here means \"without validation\"\n    uint256 valueForDataFeed = getValueForDataFeedUnsafe(dataFeedId);\n\n    validateDataFeedValueOnRead(dataFeedId, valueForDataFeed);\n    return valueForDataFeed;\n  }\n\n  /**\n   * @notice Returns the latest properly reported values for several data feeds\n   * @param dataFeedIds The array of identifiers for the requested feeds\n   * @return values Values of the requested data feeds in the corresponding order\n   */\n  function getValuesForDataFeeds(bytes32[] memory dataFeedIds) public view returns (uint256[] memory) {\n    uint256[] memory values = getValuesForDataFeedsUnsafe(dataFeedIds);\n    for (uint256 i = 0; i < dataFeedIds.length;) {\n      bytes32 dataFeedId = dataFeedIds[i];\n      getDataFeedIndex(dataFeedId); // will revert if data feed id is not supported\n      validateDataFeedValueOnRead(dataFeedId, values[i]);\n      unchecked { i++; } // reduces gas costs\n    }\n    return values;\n  }\n\n\n\n  /**\n   * @dev Reverts if proposed value for the proposed data feed id is invalid\n   * Is called on every NOT *unsafe method which reads dataFeed\n   * By default, it just checks if the value is not equal to 0, but it can be extended\n   * @param dataFeedId The data feed identifier\n   * @param valueForDataFeed Proposed value for the data feed\n   */\n  function validateDataFeedValueOnRead(bytes32 dataFeedId, uint256 valueForDataFeed) public view virtual {\n    if (valueForDataFeed == 0) {\n      revert DataFeedValueCannotBeZero(dataFeedId);\n    }\n  }\n\n  /**\n   * @dev Reverts if proposed value for the proposed data feed id is invalid\n   * Is called on every NOT *unsafe method which writes dataFeed\n   * By default, it does nothing\n   * @param dataFeedId The data feed identifier\n   * @param valueForDataFeed Proposed value for the data feed\n   */\n  function validateDataFeedValueOnWrite(bytes32 dataFeedId, uint256 valueForDataFeed) public view virtual {\n    if (valueForDataFeed == 0) {\n      revert DataFeedValueCannotBeZero(dataFeedId);\n    }\n  }\n\n  /**\n   * @dev [HIGH RISK] Returns the latest value for a given data feed without validation\n   * Important! Using this function instead of `getValueForDataFeed` may cause\n   * significant risk for your smart contracts\n   * @param dataFeedId The data feed identifier\n   * @return dataFeedValue Unvalidated value of the latest successful update\n   */\n  function getValueForDataFeedUnsafe(bytes32 dataFeedId) public view virtual returns (uint256);\n\n  /**\n   * @notice [HIGH RISK] Returns the latest properly reported values for several data feeds without validation\n   * Important! Using this function instead of `getValuesForDataFeeds` may cause\n   * significant risk for your smart contracts\n   * @param requestedDataFeedIds The array of identifiers for the requested feeds\n   * @return values Unvalidated values of the requested data feeds in the corresponding order\n   */\n  function getValuesForDataFeedsUnsafe(bytes32[] memory requestedDataFeedIds) public view virtual returns (uint256[] memory values) {\n    values = new uint256[](requestedDataFeedIds.length);\n    for (uint256 i = 0; i < requestedDataFeedIds.length;) {\n      values[i] = getValueForDataFeedUnsafe(requestedDataFeedIds[i]);\n      unchecked { i++; } // reduces gas costs\n    }\n    return values;\n  }\n}\n"
    },
    "contracts/RedStoneBaseContracts/redstone-oracles-monorepo/packages/on-chain-relayer/contracts/custom-integrations/fluid/EthUsdcRedstoneAdapterForFluidOracle.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity ^0.8.14;\n\nimport {IFluidOracle} from \"./IFluidOracle.sol\";\nimport {PriceFeedsAdapterWithoutRounds} from \"../../price-feeds/without-rounds/PriceFeedsAdapterWithoutRounds.sol\";\n\nabstract contract EthUsdcRedstoneAdapterForFluidOracle is\n  IFluidOracle,\n  PriceFeedsAdapterWithoutRounds\n{\n  // precompute keccak256(abi.encode(\"ETH/USDC\", 0x4dd0c77efa6f6d590c97573d8c70b714546e7311202ff7c11c484cc841d91bfc))\n  bytes32 constant PRICE_LOCATION_IN_STORAGE =\n    0x02967e833d2ce9c403dca2db59409302fd3c621b131bafcc7adc11d77518462c;\n\n  bytes32 constant private ETH_USDC_ID = bytes32(\"ETH/USDC\");\n\n  error UpdaterNotAuthorised(address signer);\n\n  function getDataFeedIds() public pure override returns (bytes32[] memory dataFeedIds) {\n    dataFeedIds = new bytes32[](1);\n    dataFeedIds[0] = ETH_USDC_ID;\n  }\n\n  function getDataFeedIndex(bytes32 dataFeedId) public view override virtual returns (uint256) {\n    if (dataFeedId == ETH_USDC_ID) { return 0; }\n    revert DataFeedIdNotFound(dataFeedId);\n  }\n\n  function getExchangeRate()\n    external\n    view\n    override\n    returns (uint256 exchangeRate_)\n  {\n    assembly {\n      exchangeRate_ := sload(PRICE_LOCATION_IN_STORAGE)\n    }\n  }\n\n}"
    },
    "contracts/RedStoneBaseContracts/redstone-oracles-monorepo/packages/on-chain-relayer/contracts/custom-integrations/fluid/IFluidOracle.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity ^0.8.14;\n\ninterface IFluidOracle {\n    /// @notice Get the exchange rate between the underlying asset and the peg asset\n    /// @return exchangeRate_ The exchange rate, scaled by 1e18\n    function getExchangeRate() external view returns (uint256 exchangeRate_);\n}\n\n/// @title   FluidOracle\n/// @notice  Base contract that any Oracle must implement\nabstract contract FluidOracle is IFluidOracle {\n    /// @inheritdoc IFluidOracle\n    function getExchangeRate() external view virtual returns (uint256 exchangeRate_);\n}\n"
    },
    "contracts/RedStoneBaseContracts/redstone-oracles-monorepo/packages/on-chain-relayer/contracts/custom-integrations/layerbank/ILToken.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity ^0.8.14;\n\ninterface ILToken {\n  function underlying() external view returns (address);\n}\n"
    },
    "contracts/RedStoneBaseContracts/redstone-oracles-monorepo/packages/on-chain-relayer/contracts/custom-integrations/layerbank/IPriceCalculator.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.14;\n\ninterface IPriceCalculator {\n  struct ReferenceData {\n    uint256 lastData;\n    uint256 lastUpdated;\n  }\n\n  function priceOf(address asset) external view returns (uint256);\n\n  function pricesOf(\n    address[] memory assets\n  ) external view returns (uint256[] memory);\n\n  function priceOfETH() external view returns (uint256);\n\n  function getUnderlyingPrice(address gToken) external view returns (uint256);\n\n  function getUnderlyingPrices(\n    address[] memory gTokens\n  ) external view returns (uint256[] memory);\n}\n"
    },
    "contracts/RedStoneBaseContracts/redstone-oracles-monorepo/packages/on-chain-relayer/contracts/custom-integrations/layerbank/LayerBankOracleAdapterBase.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity ^0.8.14;\n\nimport {ILToken} from \"./ILToken.sol\";\nimport {IPriceCalculator} from \"./IPriceCalculator.sol\";\nimport {PriceFeedsAdapterWithRoundsPrimaryProd} from \"../../price-feeds/data-services/PriceFeedsAdapterWithRoundsPrimaryProd.sol\";\n\nabstract contract LayerBankOracleAdapterBase is PriceFeedsAdapterWithRoundsPrimaryProd, IPriceCalculator {\n  error UnsupportedAsset(address asset);\n  error DataIsStale(uint256 lastUpdateTime);\n\n  function getDataFeedIdForAsset(address asset) public view virtual returns(bytes32);\n  function convertDecimals(bytes32 dataFeedId, uint256 valueFromRedstonePayload) public view virtual returns (uint256);\n  function requireNonStaleData() public view virtual;\n\n  function getUnderlyingAsset(address gToken) public view virtual returns(address) {\n    return ILToken(gToken).underlying();\n  }\n\n  function _uncheckedPriceOf(address asset) internal view virtual returns (uint256) {\n    bytes32 dataFeedId = getDataFeedIdForAsset(asset);\n    uint256 valueFromRedstonePayload = getValueForDataFeed(dataFeedId);\n    return convertDecimals(dataFeedId, valueFromRedstonePayload);\n  }\n\n  function priceOf(address asset) public view virtual returns (uint256) {\n    requireNonStaleData();\n    return _uncheckedPriceOf(asset);\n  }\n\n  function pricesOf(\n    address[] memory assets\n  ) external view returns (uint256[] memory values) {\n    requireNonStaleData();\n    values = new uint256[](assets.length);\n    for (uint256 i = 0; i < assets.length; i++) {\n      values[i] = _uncheckedPriceOf(assets[i]);\n    }\n  }\n\n  function getUnderlyingPrice(address gToken) public view returns (uint256) {\n    return priceOf(getUnderlyingAsset(gToken));\n  }\n\n  function getUnderlyingPrices(\n    address[] memory gTokens\n  ) public view returns (uint256[] memory values) {\n    values = new uint256[](gTokens.length);\n    for (uint256 i = 0; i < gTokens.length; i++) {\n      values[i] = getUnderlyingPrice(gTokens[i]);\n    }\n  }\n}\n"
    },
    "contracts/RedStoneBaseContracts/redstone-oracles-monorepo/packages/on-chain-relayer/contracts/custom-integrations/layerbank/LayerBankOracleAdapterV1.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity ^0.8.14;\n\nimport {LayerBankOracleAdapterBase} from \"./LayerBankOracleAdapterBase.sol\";\n\ncontract LayerBankOracleAdapterV1 is LayerBankOracleAdapterBase {\n\n  address internal constant ETH_ASSET = 0x0000000000000000000000000000000000000000;\n  uint256 internal constant MAX_ALLOWED_DATA_STALENESS = 10 hours;\n\n  bytes32 internal constant ETH_ID = bytes32(\"ETH\");\n  bytes32 internal constant USDC_ID = bytes32(\"USDC\");\n  bytes32 internal constant TIA_ID = bytes32(\"TIA\");\n  bytes32 internal constant LAB_M_ID = bytes32(\"LAB.m\");\n  bytes32 internal constant WST_ETH_ID = bytes32(\"wstETH\");\n  bytes32 internal constant STONE_ID = bytes32(\"STONE\");\n  bytes32 internal constant W_USDM_ID = bytes32(\"wUSDM\");\n  bytes32 internal constant MANTA_ID = bytes32(\"MANTA\");\n\n  function getDataFeedIdForAsset(address asset) public view virtual override returns(bytes32) {\n    if (asset == 0xb73603C5d87fA094B7314C74ACE2e64D165016fb) {\n      return USDC_ID;\n    } else if (asset == 0x6Fae4D9935E2fcb11fC79a64e917fb2BF14DaFaa) {\n      return TIA_ID;\n    } else if (asset == 0x20A512dbdC0D006f46E6cA11329034Eb3d18c997) {\n      return LAB_M_ID;\n    } else if (asset == 0x2FE3AD97a60EB7c79A976FC18Bb5fFD07Dd94BA5) {\n      return WST_ETH_ID;\n    } else if (asset == 0xEc901DA9c68E90798BbBb74c11406A32A70652C3) {\n      return STONE_ID;\n    } else if (asset == 0xbdAd407F77f44F7Da6684B416b1951ECa461FB07) {\n      return W_USDM_ID;\n    } else if (asset == 0x95CeF13441Be50d20cA4558CC0a27B601aC544E5) {\n      return MANTA_ID;\n    } else if (asset == ETH_ASSET) {\n      return ETH_ID;\n    } else {\n      revert UnsupportedAsset(asset);\n    }\n  }\n\n  function getDataFeedIds() public view virtual override returns (bytes32[] memory dataFeedIds) {\n    dataFeedIds = new bytes32[](8);\n    dataFeedIds[0] = ETH_ID;\n    dataFeedIds[1] = USDC_ID;\n    dataFeedIds[2] = TIA_ID;\n    dataFeedIds[3] = LAB_M_ID;\n    dataFeedIds[4] = WST_ETH_ID;\n    dataFeedIds[5] = STONE_ID;\n    dataFeedIds[6] = W_USDM_ID;\n    dataFeedIds[7] = MANTA_ID;\n  }\n\n  function convertDecimals(bytes32 dataFeedId, uint256 valueFromRedstonePayload) public view virtual override returns(uint256) {\n    dataFeedId; // Currently, this arg is unused, but it be required for new tokens\n    return valueFromRedstonePayload * 1e10;\n  }\n\n  function priceOfETH() public view returns (uint256) {\n    return priceOf(ETH_ASSET);\n  }\n\n  function requireNonStaleData() public view virtual override {\n    uint256 latestUpdateTime = getBlockTimestampFromLatestUpdate();\n    uint256 curTime = getBlockTimestamp();\n    if (latestUpdateTime < curTime && (curTime - latestUpdateTime) > MAX_ALLOWED_DATA_STALENESS) {\n      revert DataIsStale(latestUpdateTime);\n    }\n  }\n}\n"
    },
    "contracts/RedStoneBaseContracts/redstone-oracles-monorepo/packages/on-chain-relayer/contracts/custom-integrations/LowestGasRead.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity ^0.8.14;\n\nabstract contract LowestGasRead {\n    /**\n   * @dev [HIGH RISK] Returns the latest value for a given data feed without validation\n   * Important! Using this function instead of `getValueForDataFeed` may cause\n   * significant risk for your smart contracts\n   * @return dataFeedValue Unvalidated value of the latest successful update\n   */\n  function getBtcValueWithLowestGas() external view returns (uint256 dataFeedValue) {\n    assembly {\n      // THIS VALUE HAS TO BE PRE COMPUTED // precompute keccak256(abi.encode(\"BTC\", 0x4dd0c77efa6f6d590c97573d8c70b714546e7311202ff7c11c484cc841d91bfc))\n      dataFeedValue := sload(0xf497211eccb68cc78a757a9caed87152a70e6da38b5f59e20a3feb628cda40b8) \n    }\n  }\n}\n"
    },
    "contracts/RedStoneBaseContracts/redstone-oracles-monorepo/packages/on-chain-relayer/contracts/custom-integrations/mento/data-services/MentoAdapterPrimaryProd.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity ^0.8.14;\n\nimport {MentoAdapterBase} from \"../MentoAdapterBase.sol\";\n\nabstract contract MentoAdapterPrimaryProd is MentoAdapterBase {\n  function getUniqueSignersThreshold() public view virtual override returns (uint8) {\n    return 2;\n  }\n\n  function getAuthorisedSignerIndex(\n    address signerAddress\n  ) public view virtual override returns (uint8) {\n    if (signerAddress == 0x8BB8F32Df04c8b654987DAaeD53D6B6091e3B774) {\n      return 0;\n    } else if (signerAddress == 0xdEB22f54738d54976C4c0fe5ce6d408E40d88499) {\n      return 1;\n    } else if (signerAddress == 0x51Ce04Be4b3E32572C4Ec9135221d0691Ba7d202) {\n      return 2;\n    } else if (signerAddress == 0xDD682daEC5A90dD295d14DA4b0bec9281017b5bE) {\n      return 3;\n    } else if (signerAddress == 0x9c5AE89C4Af6aA32cE58588DBaF90d18a855B6de) {\n      return 4;\n    } else {\n      revert SignerNotAuthorised(signerAddress);\n    }\n  }\n}\n"
    },
    "contracts/RedStoneBaseContracts/redstone-oracles-monorepo/packages/on-chain-relayer/contracts/custom-integrations/mento/ISortedOracles.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n\npragma solidity ^0.8.14;\n\nimport {SortedLinkedListWithMedian} from \"./linkedlists/SortedLinkedListWithMedian.sol\";\n\n/**\n * @title Simplified interface of the SortedOracles contract\n * @author The Mento team (modified by the Redstone team)\n * @dev Some functions were removed to simplify implementation\n * of the mock SortedOracles contract. Interfaces of the functions\n * below are identical with the original ISortedOracles interface\n */\ninterface ISortedOracles {\n  function report(address, uint256, address, address) external;\n\n  function removeExpiredReports(address, uint256) external;\n\n  function getRates(\n    address\n  )\n    external\n    view\n    returns (\n      address[] memory,\n      uint256[] memory,\n      SortedLinkedListWithMedian.MedianRelation[] memory\n    );\n\n  function numTimestamps(address) external view returns (uint256);\n\n  function medianRate(address) external view returns (uint256, uint256);\n}\n"
    },
    "contracts/RedStoneBaseContracts/redstone-oracles-monorepo/packages/on-chain-relayer/contracts/custom-integrations/mento/linkedlists/LinkedList.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n\npragma solidity ^0.8.14;\n\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\n\n/**\n * @title Maintains a doubly linked list keyed by bytes32.\n * @author The Mento team (the code modified by the RedStone team)\n * @dev The code has been slightly modified to be compatible with ^0.8.0 version\n * Following the `next` pointers will lead you to the head, rather than the tail.\n */\nlibrary LinkedList {\n  using SafeMath for uint256;\n\n  struct Element {\n    bytes32 previousKey;\n    bytes32 nextKey;\n    bool exists;\n  }\n\n  struct List {\n    bytes32 head;\n    bytes32 tail;\n    uint256 numElements;\n    mapping(bytes32 => Element) elements;\n  }\n\n  /**\n   * @notice Inserts an element into a doubly linked list.\n   * @param list A storage pointer to the underlying list.\n   * @param key The key of the element to insert.\n   * @param previousKey The key of the element that comes before the element to insert.\n   * @param nextKey The key of the element that comes after the element to insert.\n   */\n  function insert(List storage list, bytes32 key, bytes32 previousKey, bytes32 nextKey) internal {\n    require(key != bytes32(0), \"Key must be defined\");\n    require(!contains(list, key), \"Can't insert an existing element\");\n    require(\n      previousKey != key && nextKey != key,\n      \"Key cannot be the same as previousKey or nextKey\"\n    );\n\n    Element storage element = list.elements[key];\n    element.exists = true;\n\n    if (list.numElements == 0) {\n      list.tail = key;\n      list.head = key;\n    } else {\n      require(\n        previousKey != bytes32(0) || nextKey != bytes32(0),\n        \"Either previousKey or nextKey must be defined\"\n      );\n\n      element.previousKey = previousKey;\n      element.nextKey = nextKey;\n\n      if (previousKey != bytes32(0)) {\n        require(\n          contains(list, previousKey),\n          \"If previousKey is defined, it must exist in the list\"\n        );\n        Element storage previousElement = list.elements[previousKey];\n        require(previousElement.nextKey == nextKey, \"previousKey must be adjacent to nextKey\");\n        previousElement.nextKey = key;\n      } else {\n        list.tail = key;\n      }\n\n      if (nextKey != bytes32(0)) {\n        require(contains(list, nextKey), \"If nextKey is defined, it must exist in the list\");\n        Element storage nextElement = list.elements[nextKey];\n        require(nextElement.previousKey == previousKey, \"previousKey must be adjacent to nextKey\");\n        nextElement.previousKey = key;\n      } else {\n        list.head = key;\n      }\n    }\n\n    list.numElements = list.numElements.add(1);\n  }\n\n  /**\n   * @notice Inserts an element at the tail of the doubly linked list.\n   * @param list A storage pointer to the underlying list.\n   * @param key The key of the element to insert.\n   */\n  function push(List storage list, bytes32 key) internal {\n    insert(list, key, bytes32(0), list.tail);\n  }\n\n  /**\n   * @notice Removes an element from the doubly linked list.\n   * @param list A storage pointer to the underlying list.\n   * @param key The key of the element to remove.\n   */\n  function remove(List storage list, bytes32 key) internal {\n    Element storage element = list.elements[key];\n    require(key != bytes32(0) && contains(list, key), \"key not in list\");\n    if (element.previousKey != bytes32(0)) {\n      Element storage previousElement = list.elements[element.previousKey];\n      previousElement.nextKey = element.nextKey;\n    } else {\n      list.tail = element.nextKey;\n    }\n\n    if (element.nextKey != bytes32(0)) {\n      Element storage nextElement = list.elements[element.nextKey];\n      nextElement.previousKey = element.previousKey;\n    } else {\n      list.head = element.previousKey;\n    }\n\n    delete list.elements[key];\n    list.numElements = list.numElements.sub(1);\n  }\n\n  /**\n   * @notice Updates an element in the list.\n   * @param list A storage pointer to the underlying list.\n   * @param key The element key.\n   * @param previousKey The key of the element that comes before the updated element.\n   * @param nextKey The key of the element that comes after the updated element.\n   */\n  function update(List storage list, bytes32 key, bytes32 previousKey, bytes32 nextKey) internal {\n    require(\n      key != bytes32(0) && key != previousKey && key != nextKey && contains(list, key),\n      \"key on in list\"\n    );\n    remove(list, key);\n    insert(list, key, previousKey, nextKey);\n  }\n\n  /**\n   * @notice Returns whether or not a particular key is present in the sorted list.\n   * @param list A storage pointer to the underlying list.\n   * @param key The element key.\n   * @return Whether or not the key is in the sorted list.\n   */\n  function contains(List storage list, bytes32 key) internal view returns (bool) {\n    return list.elements[key].exists;\n  }\n\n  /**\n   * @notice Returns the keys of the N elements at the head of the list.\n   * @param list A storage pointer to the underlying list.\n   * @param n The number of elements to return.\n   * @return The keys of the N elements at the head of the list.\n   * @dev Reverts if n is greater than the number of elements in the list.\n   */\n  function headN(List storage list, uint256 n) internal view returns (bytes32[] memory) {\n    require(n <= list.numElements, \"not enough elements\");\n    bytes32[] memory keys = new bytes32[](n);\n    bytes32 key = list.head;\n    for (uint256 i = 0; i < n; i = i.add(1)) {\n      keys[i] = key;\n      key = list.elements[key].previousKey;\n    }\n    return keys;\n  }\n\n  /**\n   * @notice Gets all element keys from the doubly linked list.\n   * @param list A storage pointer to the underlying list.\n   * @return All element keys from head to tail.\n   */\n  function getKeys(List storage list) internal view returns (bytes32[] memory) {\n    return headN(list, list.numElements);\n  }\n}\n"
    },
    "contracts/RedStoneBaseContracts/redstone-oracles-monorepo/packages/on-chain-relayer/contracts/custom-integrations/mento/linkedlists/SortedLinkedList.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n\npragma solidity ^0.8.14;\n\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\nimport \"./LinkedList.sol\";\n\n/**\n * @title Maintains a sorted list of unsigned ints keyed by bytes32.\n * @author The Mento team (the code modified by the RedStone team)\n * @dev The code has been slightly modified to be compatible with ^0.8.0 version\n */\nlibrary SortedLinkedList {\n  using SafeMath for uint256;\n  using LinkedList for LinkedList.List;\n\n  struct List {\n    LinkedList.List list;\n    mapping(bytes32 => uint256) values;\n  }\n\n  /**\n   * @notice Inserts an element into a doubly linked list.\n   * @param list A storage pointer to the underlying list.\n   * @param key The key of the element to insert.\n   * @param value The element value.\n   * @param lesserKey The key of the element less than the element to insert.\n   * @param greaterKey The key of the element greater than the element to insert.\n   */\n  function insert(\n    List storage list,\n    bytes32 key,\n    uint256 value,\n    bytes32 lesserKey,\n    bytes32 greaterKey\n  ) internal {\n    require(\n      key != bytes32(0) && key != lesserKey && key != greaterKey && !contains(list, key),\n      \"invalid key\"\n    );\n    require(\n      (lesserKey != bytes32(0) || greaterKey != bytes32(0)) || list.list.numElements == 0,\n      \"greater and lesser key zero\"\n    );\n    require(contains(list, lesserKey) || lesserKey == bytes32(0), \"invalid lesser key\");\n    require(contains(list, greaterKey) || greaterKey == bytes32(0), \"invalid greater key\");\n    (lesserKey, greaterKey) = getLesserAndGreater(list, value, lesserKey, greaterKey);\n    list.list.insert(key, lesserKey, greaterKey);\n    list.values[key] = value;\n  }\n\n  /**\n   * @notice Removes an element from the doubly linked list.\n   * @param list A storage pointer to the underlying list.\n   * @param key The key of the element to remove.\n   */\n  function remove(List storage list, bytes32 key) internal {\n    list.list.remove(key);\n    list.values[key] = 0;\n  }\n\n  /**\n   * @notice Updates an element in the list.\n   * @param list A storage pointer to the underlying list.\n   * @param key The element key.\n   * @param value The element value.\n   * @param lesserKey The key of the element will be just left of `key` after the update.\n   * @param greaterKey The key of the element will be just right of `key` after the update.\n   * @dev Note that only one of \"lesserKey\" or \"greaterKey\" needs to be correct to reduce friction.\n   */\n  function update(\n    List storage list,\n    bytes32 key,\n    uint256 value,\n    bytes32 lesserKey,\n    bytes32 greaterKey\n  ) internal {\n    remove(list, key);\n    insert(list, key, value, lesserKey, greaterKey);\n  }\n\n  /**\n   * @notice Inserts an element at the tail of the doubly linked list.\n   * @param list A storage pointer to the underlying list.\n   * @param key The key of the element to insert.\n   */\n  function push(List storage list, bytes32 key) internal {\n    insert(list, key, 0, bytes32(0), list.list.tail);\n  }\n\n  /**\n   * @notice Removes N elements from the head of the list and returns their keys.\n   * @param list A storage pointer to the underlying list.\n   * @param n The number of elements to pop.\n   * @return The keys of the popped elements.\n   */\n  function popN(List storage list, uint256 n) internal returns (bytes32[] memory) {\n    require(n <= list.list.numElements, \"not enough elements\");\n    bytes32[] memory keys = new bytes32[](n);\n    for (uint256 i = 0; i < n; i = i.add(1)) {\n      bytes32 key = list.list.head;\n      keys[i] = key;\n      remove(list, key);\n    }\n    return keys;\n  }\n\n  /**\n   * @notice Returns whether or not a particular key is present in the sorted list.\n   * @param list A storage pointer to the underlying list.\n   * @param key The element key.\n   * @return Whether or not the key is in the sorted list.\n   */\n  function contains(List storage list, bytes32 key) internal view returns (bool) {\n    return list.list.contains(key);\n  }\n\n  /**\n   * @notice Returns the value for a particular key in the sorted list.\n   * @param list A storage pointer to the underlying list.\n   * @param key The element key.\n   * @return The element value.\n   */\n  function getValue(List storage list, bytes32 key) internal view returns (uint256) {\n    return list.values[key];\n  }\n\n  /**\n   * @notice Gets all elements from the doubly linked list.\n   * @param list A storage pointer to the underlying list.\n   * @return Array of all keys in the list.\n   * @return Values corresponding to keys, which will be ordered largest to smallest.\n   */\n  function getElements(\n    List storage list\n  ) internal view returns (bytes32[] memory, uint256[] memory) {\n    bytes32[] memory keys = getKeys(list);\n    uint256[] memory values = new uint256[](keys.length);\n    for (uint256 i = 0; i < keys.length; i = i.add(1)) {\n      values[i] = list.values[keys[i]];\n    }\n    return (keys, values);\n  }\n\n  /**\n   * @notice Gets all element keys from the doubly linked list.\n   * @param list A storage pointer to the underlying list.\n   * @return All element keys from head to tail.\n   */\n  function getKeys(List storage list) internal view returns (bytes32[] memory) {\n    return list.list.getKeys();\n  }\n\n  /**\n   * @notice Returns first N greatest elements of the list.\n   * @param list A storage pointer to the underlying list.\n   * @param n The number of elements to return.\n   * @return The keys of the first n elements.\n   * @dev Reverts if n is greater than the number of elements in the list.\n   */\n  function headN(List storage list, uint256 n) internal view returns (bytes32[] memory) {\n    return list.list.headN(n);\n  }\n\n  /**\n   * @notice Returns the keys of the elements greaterKey than and less than the provided value.\n   * @param list A storage pointer to the underlying list.\n   * @param value The element value.\n   * @param lesserKey The key of the element which could be just left of the new value.\n   * @param greaterKey The key of the element which could be just right of the new value.\n   * @return correctLesserValue The correct lesserKey keys.\n   * @return correctGreaterValue The correct greaterKey keys.\n   */\n  function getLesserAndGreater(\n    List storage list,\n    uint256 value,\n    bytes32 lesserKey,\n    bytes32 greaterKey\n  ) private view returns (bytes32 correctLesserValue, bytes32 correctGreaterValue) {\n    // Check for one of the following conditions and fail if none are met:\n    //   1. The value is less than the current lowest value\n    //   2. The value is greater than the current greatest value\n    //   3. The value is just greater than the value for `lesserKey`\n    //   4. The value is just less than the value for `greaterKey`\n    if (lesserKey == bytes32(0) && isValueBetween(list, value, lesserKey, list.list.tail)) {\n      return (lesserKey, list.list.tail);\n    } else if (\n      greaterKey == bytes32(0) && isValueBetween(list, value, list.list.head, greaterKey)\n    ) {\n      return (list.list.head, greaterKey);\n    } else if (\n      lesserKey != bytes32(0) &&\n      isValueBetween(list, value, lesserKey, list.list.elements[lesserKey].nextKey)\n    ) {\n      return (lesserKey, list.list.elements[lesserKey].nextKey);\n    } else if (\n      greaterKey != bytes32(0) &&\n      isValueBetween(list, value, list.list.elements[greaterKey].previousKey, greaterKey)\n    ) {\n      return (list.list.elements[greaterKey].previousKey, greaterKey);\n    } else {\n      require(false, \"get lesser and greater failure\");\n    }\n  }\n\n  /**\n   * @notice Returns whether or not a given element is between two other elements.\n   * @param list A storage pointer to the underlying list.\n   * @param value The element value.\n   * @param lesserKey The key of the element whose value should be lesserKey.\n   * @param greaterKey The key of the element whose value should be greaterKey.\n   * @return True if the given element is between the two other elements.\n   */\n  function isValueBetween(\n    List storage list,\n    uint256 value,\n    bytes32 lesserKey,\n    bytes32 greaterKey\n  ) private view returns (bool) {\n    bool isLesser = lesserKey == bytes32(0) || list.values[lesserKey] <= value;\n    bool isGreater = greaterKey == bytes32(0) || list.values[greaterKey] >= value;\n    return isLesser && isGreater;\n  }\n}\n"
    },
    "contracts/RedStoneBaseContracts/redstone-oracles-monorepo/packages/on-chain-relayer/contracts/custom-integrations/mento/linkedlists/SortedLinkedListWithMedian.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n\npragma solidity ^0.8.14;\n\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\nimport \"./LinkedList.sol\";\nimport \"./SortedLinkedList.sol\";\n\n/**\n * @title Maintains a sorted list of unsigned ints keyed by bytes32.\n * @author The Mento team (the code modified by the RedStone team)\n * @dev The code has been slightly modified to be compatible with ^0.8.0 version\n */\nlibrary SortedLinkedListWithMedian {\n  using SafeMath for uint256;\n  using SortedLinkedList for SortedLinkedList.List;\n\n  enum MedianAction {\n    None,\n    Lesser,\n    Greater\n  }\n\n  enum MedianRelation {\n    Undefined,\n    Lesser,\n    Greater,\n    Equal\n  }\n\n  struct List {\n    SortedLinkedList.List list;\n    bytes32 median;\n    mapping(bytes32 => MedianRelation) relation;\n  }\n\n  /**\n   * @notice Inserts an element into a doubly linked list.\n   * @param list A storage pointer to the underlying list.\n   * @param key The key of the element to insert.\n   * @param value The element value.\n   * @param lesserKey The key of the element less than the element to insert.\n   * @param greaterKey The key of the element greater than the element to insert.\n   */\n  function insert(\n    List storage list,\n    bytes32 key,\n    uint256 value,\n    bytes32 lesserKey,\n    bytes32 greaterKey\n  ) internal {\n    list.list.insert(key, value, lesserKey, greaterKey);\n    LinkedList.Element storage element = list.list.list.elements[key];\n\n    MedianAction action = MedianAction.None;\n    if (list.list.list.numElements == 1) {\n      list.median = key;\n      list.relation[key] = MedianRelation.Equal;\n    } else if (list.list.list.numElements % 2 == 1) {\n      // When we have an odd number of elements, and the element that we inserted is less than\n      // the previous median, we need to slide the median down one element, since we had previously\n      // selected the greater of the two middle elements.\n      if (\n        element.previousKey == bytes32(0) ||\n        list.relation[element.previousKey] == MedianRelation.Lesser\n      ) {\n        action = MedianAction.Lesser;\n        list.relation[key] = MedianRelation.Lesser;\n      } else {\n        list.relation[key] = MedianRelation.Greater;\n      }\n    } else {\n      // When we have an even number of elements, and the element that we inserted is greater than\n      // the previous median, we need to slide the median up one element, since we always select\n      // the greater of the two middle elements.\n      if (\n        element.nextKey == bytes32(0) || list.relation[element.nextKey] == MedianRelation.Greater\n      ) {\n        action = MedianAction.Greater;\n        list.relation[key] = MedianRelation.Greater;\n      } else {\n        list.relation[key] = MedianRelation.Lesser;\n      }\n    }\n    updateMedian(list, action);\n  }\n\n  /**\n   * @notice Removes an element from the doubly linked list.\n   * @param list A storage pointer to the underlying list.\n   * @param key The key of the element to remove.\n   */\n  function remove(List storage list, bytes32 key) internal {\n    MedianAction action = MedianAction.None;\n    if (list.list.list.numElements == 0) {\n      list.median = bytes32(0);\n    } else if (list.list.list.numElements % 2 == 0) {\n      // When we have an even number of elements, we always choose the higher of the two medians.\n      // Thus, if the element we're removing is greaterKey than or equal to the median we need to\n      // slide the median left by one.\n      if (\n        list.relation[key] == MedianRelation.Greater || list.relation[key] == MedianRelation.Equal\n      ) {\n        action = MedianAction.Lesser;\n      }\n    } else {\n      // When we don't have an even number of elements, we just choose the median value.\n      // Thus, if the element we're removing is less than or equal to the median, we need to slide\n      // median right by one.\n      if (\n        list.relation[key] == MedianRelation.Lesser || list.relation[key] == MedianRelation.Equal\n      ) {\n        action = MedianAction.Greater;\n      }\n    }\n    updateMedian(list, action);\n\n    list.list.remove(key);\n  }\n\n  /**\n   * @notice Updates an element in the list.\n   * @param list A storage pointer to the underlying list.\n   * @param key The element key.\n   * @param value The element value.\n   * @param lesserKey The key of the element will be just left of `key` after the update.\n   * @param greaterKey The key of the element will be just right of `key` after the update.\n   * @dev Note that only one of \"lesserKey\" or \"greaterKey\" needs to be correct to reduce friction.\n   */\n  function update(\n    List storage list,\n    bytes32 key,\n    uint256 value,\n    bytes32 lesserKey,\n    bytes32 greaterKey\n  ) internal {\n    remove(list, key);\n    insert(list, key, value, lesserKey, greaterKey);\n  }\n\n  /**\n   * @notice Inserts an element at the tail of the doubly linked list.\n   * @param list A storage pointer to the underlying list.\n   * @param key The key of the element to insert.\n   */\n  function push(List storage list, bytes32 key) internal {\n    insert(list, key, 0, bytes32(0), list.list.list.tail);\n  }\n\n  /**\n   * @notice Removes N elements from the head of the list and returns their keys.\n   * @param list A storage pointer to the underlying list.\n   * @param n The number of elements to pop.\n   * @return The keys of the popped elements.\n   */\n  function popN(List storage list, uint256 n) internal returns (bytes32[] memory) {\n    require(n <= list.list.list.numElements, \"not enough elements\");\n    bytes32[] memory keys = new bytes32[](n);\n    for (uint256 i = 0; i < n; i = i.add(1)) {\n      bytes32 key = list.list.list.head;\n      keys[i] = key;\n      remove(list, key);\n    }\n    return keys;\n  }\n\n  /**\n   * @notice Returns whether or not a particular key is present in the sorted list.\n   * @param list A storage pointer to the underlying list.\n   * @param key The element key.\n   * @return Whether or not the key is in the sorted list.\n   */\n  function contains(List storage list, bytes32 key) internal view returns (bool) {\n    return list.list.contains(key);\n  }\n\n  /**\n   * @notice Returns the value for a particular key in the sorted list.\n   * @param list A storage pointer to the underlying list.\n   * @param key The element key.\n   * @return The element value.\n   */\n  function getValue(List storage list, bytes32 key) internal view returns (uint256) {\n    return list.list.values[key];\n  }\n\n  /**\n   * @notice Returns the median value of the sorted list.\n   * @param list A storage pointer to the underlying list.\n   * @return The median value.\n   */\n  function getMedianValue(List storage list) internal view returns (uint256) {\n    return getValue(list, list.median);\n  }\n\n  /**\n   * @notice Returns the key of the first element in the list.\n   * @param list A storage pointer to the underlying list.\n   * @return The key of the first element in the list.\n   */\n  function getHead(List storage list) internal view returns (bytes32) {\n    return list.list.list.head;\n  }\n\n  /**\n   * @notice Returns the key of the median element in the list.\n   * @param list A storage pointer to the underlying list.\n   * @return The key of the median element in the list.\n   */\n  function getMedian(List storage list) internal view returns (bytes32) {\n    return list.median;\n  }\n\n  /**\n   * @notice Returns the key of the last element in the list.\n   * @param list A storage pointer to the underlying list.\n   * @return The key of the last element in the list.\n   */\n  function getTail(List storage list) internal view returns (bytes32) {\n    return list.list.list.tail;\n  }\n\n  /**\n   * @notice Returns the number of elements in the list.\n   * @param list A storage pointer to the underlying list.\n   * @return The number of elements in the list.\n   */\n  function getNumElements(List storage list) internal view returns (uint256) {\n    return list.list.list.numElements;\n  }\n\n  /**\n   * @notice Gets all elements from the doubly linked list.\n   * @param list A storage pointer to the underlying list.\n   * @return Array of all keys in the list.\n   * @return Values corresponding to keys, which will be ordered largest to smallest.\n   * @return Array of relations to median of corresponding list elements.\n   */\n  function getElements(\n    List storage list\n  ) internal view returns (bytes32[] memory, uint256[] memory, MedianRelation[] memory) {\n    bytes32[] memory keys = getKeys(list);\n    uint256[] memory values = new uint256[](keys.length);\n    MedianRelation[] memory relations = new MedianRelation[](keys.length);\n    for (uint256 i = 0; i < keys.length; i = i.add(1)) {\n      values[i] = list.list.values[keys[i]];\n      relations[i] = list.relation[keys[i]];\n    }\n    return (keys, values, relations);\n  }\n\n  /**\n   * @notice Gets all element keys from the doubly linked list.\n   * @param list A storage pointer to the underlying list.\n   * @return All element keys from head to tail.\n   */\n  function getKeys(List storage list) internal view returns (bytes32[] memory) {\n    return list.list.getKeys();\n  }\n\n  /**\n   * @notice Moves the median pointer right or left of its current value.\n   * @param list A storage pointer to the underlying list.\n   * @param action Which direction to move the median pointer.\n   */\n  function updateMedian(List storage list, MedianAction action) private {\n    LinkedList.Element storage previousMedian = list.list.list.elements[list.median];\n    if (action == MedianAction.Lesser) {\n      list.relation[list.median] = MedianRelation.Greater;\n      list.median = previousMedian.previousKey;\n    } else if (action == MedianAction.Greater) {\n      list.relation[list.median] = MedianRelation.Lesser;\n      list.median = previousMedian.nextKey;\n    }\n    list.relation[list.median] = MedianRelation.Equal;\n  }\n}\n"
    },
    "contracts/RedStoneBaseContracts/redstone-oracles-monorepo/packages/on-chain-relayer/contracts/custom-integrations/mento/MentoAdapterBase.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity ^0.8.14;\n\nimport {Initializable} from \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\nimport {ISortedOracles} from \"./ISortedOracles.sol\";\nimport {RedstoneAdapterBase} from \"../../core/RedstoneAdapterBase.sol\";\n\n/**\n * @title Redstone oracles adapter for the Mento SortedOracles contract\n * @author The Redstone Oracles team\n * @dev This contract should be whitelisted as an oracle client in the\n * SortedOracles contract. It allows anyone to push signed oracle data\n * to report them in the Mento SortedOracles contract. It is ownable,\n * the owner can manage delivered data feeds and corresponding token\n * addresses.\n *\n */\nabstract contract MentoAdapterBase is RedstoneAdapterBase, Initializable {\n  error TokenNotFoundForIndex(uint256 tokenIndex);\n\n  struct DataFeedDetails {\n    bytes32 dataFeedId;\n    address tokenAddress;\n  }\n\n  // RedStone provides values with 8 decimals\n  // Mento sorted oracles expect 24 decimals (24 - 8 = 16)\n  uint256 internal constant PRICE_MULTIPLIER = 1e16;\n\n  // 68 = 4 (fun selector) + 32 (proposedTimestamp) + 32 (size of one array element)\n  uint256 internal constant INITIAL_CALLDATA_OFFSET = 68;\n  uint256 internal constant LOCATION_IN_SORTED_LIST_BYTE_SIZE = 64;\n\n  struct LocationInSortedLinkedList {\n    address lesserKey;\n    address greaterKey;\n  }\n\n  /**\n   * @dev Helpful function for upgradable contracts\n   */\n  function initialize() public initializer {\n    // We don't have storage variables, but we keep this function\n    // Because it is used for contract setup in upgradable contracts\n  }\n\n  // This function must be overriden\n  function getSortedOracles()\n    public\n    view\n    virtual\n    returns (ISortedOracles sortedOracles);\n\n  /**\n   * @notice Used for getting proposed values from RedStone's data packages\n   * @param dataFeedIds An array of data feed identifiers\n   * @return values The normalized values for corresponding data feeds\n   */\n  function getNormalizedOracleValuesFromTxCalldata(\n    bytes32[] calldata dataFeedIds\n  ) public view returns (uint256[] memory) {\n    uint256[] memory values = getOracleNumericValuesFromTxMsg(dataFeedIds);\n    for (uint256 i = 0; i < values.length; ) {\n      values[i] = normalizeRedstoneValueForMento(values[i]);\n      unchecked {\n        i++;\n      } // reduces gas costs\n    }\n    return values;\n  }\n\n  /**\n   * @notice Helpful function to simplify the mento relayer implementation\n   */\n  function updatePriceValuesAndCleanOldReports(\n    uint256 proposedTimestamp,\n    LocationInSortedLinkedList[] calldata locationsInSortedLinkedLists\n  ) external {\n    updatePriceValues(proposedTimestamp, locationsInSortedLinkedLists);\n    removeAllExpiredReports();\n  }\n\n  function removeAllExpiredReports() public {\n    uint256 tokensLength = getDataFeedsCount();\n    ISortedOracles sortedOracles = getSortedOracles();\n    for (uint256 tokenIndex = 0; tokenIndex < tokensLength; ) {\n      (, address tokenAddress) = getTokenDetailsAtIndex(tokenIndex);\n      uint256 curNumberOfReports = sortedOracles.numTimestamps(tokenAddress);\n      if (curNumberOfReports > 0) {\n        sortedOracles.removeExpiredReports(\n          tokenAddress,\n          curNumberOfReports - 1\n        );\n      }\n      unchecked {\n        tokenIndex++;\n      } // reduces gas costs\n    }\n  }\n\n  function normalizeRedstoneValueForMento(\n    uint256 valueFromRedstone\n  ) public pure returns (uint256) {\n    return PRICE_MULTIPLIER * valueFromRedstone;\n  }\n\n  function convertMentoValueToRedstoneValue(\n    uint256 mentoValue\n  ) public pure returns (uint256) {\n    return mentoValue / PRICE_MULTIPLIER;\n  }\n\n  /**\n   * @notice Extracts Redstone's oracle values from calldata, verifying signatures\n   * and timestamps, and reports it to the SortedOracles contract\n   * @param proposedTimestamp Timestamp that should be lesser or equal to each\n   * timestamp from the signed data packages in calldata\n   * @param locationsInSortedLinkedLists The array of locations in linked list for reported values\n   */\n  function updatePriceValues(\n    uint256 proposedTimestamp,\n    LocationInSortedLinkedList[] calldata locationsInSortedLinkedLists\n  ) public {\n    locationsInSortedLinkedLists; // This argument is used later (extracted from calldata)\n    updateDataFeedsValues(proposedTimestamp);\n  }\n\n  function _validateAndUpdateDataFeedsValues(\n    bytes32[] memory dataFeedIds,\n    uint256[] memory values\n  ) internal override {\n    LocationInSortedLinkedList[]\n      memory locationsInSortedList = extractLinkedListLocationsFromCalldata();\n    for (uint256 dataFeedIndex = 0; dataFeedIndex < dataFeedIds.length; ) {\n      (, address tokenAddress) = getTokenDetailsAtIndex(dataFeedIndex);\n      uint256 priceValue = normalizeRedstoneValueForMento(\n        values[dataFeedIndex]\n      );\n      LocationInSortedLinkedList memory location = locationsInSortedList[\n        dataFeedIndex\n      ];\n\n      getSortedOracles().report(\n        tokenAddress,\n        priceValue,\n        location.lesserKey,\n        location.greaterKey\n      );\n\n      unchecked {\n        dataFeedIndex++;\n      } // reduces gas costs\n    }\n  }\n\n  function extractLinkedListLocationsFromCalldata()\n    private\n    pure\n    returns (LocationInSortedLinkedList[] memory locationsInSortedList)\n  {\n    uint256 calldataOffset = INITIAL_CALLDATA_OFFSET;\n    uint256 arrayLength = abi.decode(\n      msg.data[calldataOffset:calldataOffset + STANDARD_SLOT_BS],\n      (uint256)\n    );\n\n    calldataOffset += STANDARD_SLOT_BS;\n\n    locationsInSortedList = new LocationInSortedLinkedList[](arrayLength);\n    for (uint256 i = 0; i < arrayLength; ) {\n      locationsInSortedList[i] = abi.decode(\n        msg.data[calldataOffset:calldataOffset +\n          LOCATION_IN_SORTED_LIST_BYTE_SIZE],\n        (LocationInSortedLinkedList)\n      );\n      calldataOffset += LOCATION_IN_SORTED_LIST_BYTE_SIZE;\n      unchecked {\n        i++;\n      } // reduces gas costs\n    }\n  }\n\n  function getDataFeedIds() public view override returns (bytes32[] memory) {\n    uint256 dataFeedsCount = getDataFeedsCount();\n    bytes32[] memory dataFeedIds = new bytes32[](dataFeedsCount);\n    for (uint256 dataFeedIndex = 0; dataFeedIndex < dataFeedsCount; ) {\n      (dataFeedIds[dataFeedIndex], ) = getTokenDetailsAtIndex(dataFeedIndex);\n      unchecked {\n        dataFeedIndex++;\n      } // reduces gas costs\n    }\n\n    return dataFeedIds;\n  }\n\n  // This function is used by mento relayer\n  function getDataFeeds() public view returns (DataFeedDetails[] memory) {\n    uint256 dataFeedsCount = getDataFeedsCount();\n    DataFeedDetails[] memory dataFeeds = new DataFeedDetails[](dataFeedsCount);\n    for (uint256 dataFeedIndex = 0; dataFeedIndex < dataFeedsCount; ) {\n      (bytes32 dataFeedId, address tokenAddress) = getTokenDetailsAtIndex(\n        dataFeedIndex\n      );\n      dataFeeds[dataFeedIndex] = DataFeedDetails({\n        dataFeedId: dataFeedId,\n        tokenAddress: tokenAddress\n      });\n      unchecked {\n        dataFeedIndex++;\n      } // reduces gas costs\n    }\n    return dataFeeds;\n  }\n\n  // This function must be overriden in the child contract\n  function getTokenDetailsAtIndex(\n    uint256 tokenIndex\n  ) public view virtual returns (bytes32 dataFeedId, address tokenAddress);\n\n  // This function must be overriden in the child contract\n  function getDataFeedsCount() public view virtual returns (uint256);\n\n  function getTokenIndexByDataFeedId(\n    bytes32 dataFeedId\n  ) public view virtual returns (uint256) {\n    uint256 dataFeedsCount = getDataFeedsCount();\n    for (uint256 dataFeedIndex = 0; dataFeedIndex < dataFeedsCount; ) {\n      (bytes32 dataFeedIdAtIndex, ) = getTokenDetailsAtIndex(dataFeedIndex);\n      if (dataFeedId == dataFeedIdAtIndex) {\n        return dataFeedIndex;\n      }\n      unchecked {\n        dataFeedIndex++;\n      } // reduces gas costs\n    }\n\n    revert DataFeedIdNotFound(dataFeedId);\n  }\n\n  // [HIGH RISK] Using this function directly may cause significant risk\n  function getValueForDataFeedUnsafe(\n    bytes32 dataFeedId\n  ) public view override returns (uint256) {\n    uint256 tokenIndex = getTokenIndexByDataFeedId(dataFeedId);\n    (, address tokenAddress) = getTokenDetailsAtIndex(tokenIndex);\n    (uint256 medianRate, ) = getSortedOracles().medianRate(tokenAddress);\n    return convertMentoValueToRedstoneValue(medianRate);\n  }\n}\n"
    },
    "contracts/RedStoneBaseContracts/redstone-oracles-monorepo/packages/on-chain-relayer/contracts/erc7412/IERC7412.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n/**\n * @title ERC-7412 Off-Chain Data Retrieval Contract\n */\ninterface IERC7412 {\n\t/**\n\t * @dev Emitted when an oracle is requested to provide data. Upon receipt of this error, a wallet client\n\t * should automatically resolve the requested oracle data and call fulfillOracleQuery.\n\t * @param oracleContract The address of the oracle contract (which is also the fulfillment contract).\n\t * @param oracleQuery The query to be sent to the off-chain interface.\n\t */\n\terror OracleDataRequired(address oracleContract, bytes oracleQuery);\n\n\t/**\n\t * @dev Emitted when the recently posted oracle data requires a fee to be paid. Upon receipt of this error,\n\t * a wallet client should attach the requested feeAmount to the most recently posted oracle data transaction\n\t */\n\terror FeeRequired(uint feeAmount);\n\n\t/**\n\t * @dev Returns a human-readable identifier of the oracle contract. This should map to a URL and API\n\t * key on the client side.\n\t * @return The oracle identifier.\n\t */\n\tfunction oracleId() view external returns (bytes32);\n\n\t/**\n\t * @dev Upon resolving the oracle query, the client should call this function to post the data to the\n\t * blockchain.\n\t * @param signedOffchainData The data that was returned from the off-chain interface, signed by the oracle.\n\t */\n\tfunction fulfillOracleQuery(bytes calldata signedOffchainData) payable external;\n}\n"
    },
    "contracts/RedStoneBaseContracts/redstone-oracles-monorepo/packages/on-chain-relayer/contracts/erc7412/RedstonePrimaryProdWithoutRoundsERC7412.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.12;\n\nimport {IERC7412} from './IERC7412.sol';\nimport {MergedSinglePriceFeedAdapterWithoutRoundsPrimaryProd} from '../price-feeds/data-services/MergedSinglePriceFeedAdapterWithoutRoundsPrimaryProd.sol';\n\n /**\n * @title Implementation of a price feeds adapter and price feed and ERC7412\n * @author The Redstone Oracles team\n * @dev This contract is abstract, the following functions should be\n * implemented in the actual contract before deployment:\n * - getDataFeedId\n * - getTTL\n */\n abstract contract RedstonePrimaryProdWithoutRoundsERC7412 is IERC7412, MergedSinglePriceFeedAdapterWithoutRoundsPrimaryProd {\n    bytes32 constant ORACLE_ID = bytes32(\"REDSTONE\");\n\n    function getTTL() view internal virtual returns (uint256);\n   \n    function oracleId() pure external returns (bytes32) {\n        return ORACLE_ID;\n    }\n\n    function getAllowedTimestampDiffsInSeconds() public view override virtual returns (uint256 maxDataAheadSeconds, uint256 maxDataDelaySeconds) {\n        maxDataAheadSeconds = 120;\n        maxDataDelaySeconds = 120;\n    }\n\n    function validateDataFeedValueOnRead(bytes32 dataFeedId, uint256 valueForDataFeedId) public view override virtual {\n        super.validateDataFeedValueOnRead(dataFeedId, valueForDataFeedId);\n        uint256 lastTimestamp = getBlockTimestampFromLatestUpdate();\n        if (block.timestamp - lastTimestamp > getTTL()) {\n            revert OracleDataRequired(\n                address(this),\n                abi.encode(getDataFeedId(), getUniqueSignersThreshold(), getDataServiceId())\n            );\n        }\n    }\n\n    function fulfillOracleQuery(bytes calldata signedOffchainData) payable external {\n        (uint256 dataTimestamp) = abi.decode(signedOffchainData, (uint256));\n        updateDataFeedsValues(dataTimestamp);\n    }\n}\n"
    },
    "contracts/RedStoneBaseContracts/redstone-oracles-monorepo/packages/on-chain-relayer/contracts/mocks/FluidOracleRedstoneAdapterMock.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity ^0.8.14;\n\nimport {EthUsdcRedstoneAdapterForFluidOracle} from \"../custom-integrations/fluid/EthUsdcRedstoneAdapterForFluidOracle.sol\";\nimport {AuthorisedMockSignersBase} from \"@redstone-finance/evm-connector/contracts/mocks/AuthorisedMockSignersBase.sol\";\nimport {PriceFeedsAdapterWithoutRounds} from \"../price-feeds/without-rounds/PriceFeedsAdapterWithoutRounds.sol\";\n\ncontract FluidOracleRedstoneAdapterMock is EthUsdcRedstoneAdapterForFluidOracle,AuthorisedMockSignersBase {\n  function getUniqueSignersThreshold() public view virtual override returns (uint8) {\n    return 2;\n  }\n\n  function getAuthorisedSignerIndex(address signerAddress)\n    public\n    view\n    virtual\n    override\n    returns (uint8)\n  {\n    return getAuthorisedMockSignerIndex(signerAddress);\n  }\n}"
    },
    "contracts/RedStoneBaseContracts/redstone-oracles-monorepo/packages/on-chain-relayer/contracts/mocks/LayerBankOracleAdapterMock.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity ^0.8.14;\n\nimport {AuthorisedMockSignersBase} from \"@redstone-finance/evm-connector/contracts/mocks/AuthorisedMockSignersBase.sol\";\nimport {LayerBankOracleAdapterBase} from \"../custom-integrations/layerbank/LayerBankOracleAdapterBase.sol\";\n\ncontract LayerBankOracleAdapterMock is LayerBankOracleAdapterBase, AuthorisedMockSignersBase {\n  function getUniqueSignersThreshold() public view virtual override returns (uint8) {\n    return 2;\n  }\n\n  function getAuthorisedSignerIndex(\n    address signerAddress\n  ) public view virtual override returns (uint8) {\n    return getAuthorisedMockSignerIndex(signerAddress);\n  }\n\n  function getDataFeedIdForAsset(address asset) public view virtual override returns(bytes32) {\n    if (asset == 0x0000000000000000000000000000000000000001) {\n      return bytes32(\"BTC\");\n    } else {\n      revert UnsupportedAsset(asset);\n    }\n  }\n\n  function getDataFeedIds() public view virtual override returns (bytes32[] memory dataFeedIds) {\n    dataFeedIds = new bytes32[](1);\n    dataFeedIds[0] = bytes32(\"BTC\");\n  }\n\n  function requireNonStaleData() public view virtual override {\n    // No staleness check in this mock contract\n  }\n\n  function convertDecimals(bytes32 dataFeedId, uint256 valueFromRedstonePayload) public view virtual override returns(uint256) {\n    dataFeedId;\n    return valueFromRedstonePayload * 1e10;\n  }\n\n  function priceOfETH() public view returns (uint256) {\n    return priceOf(0x0000000000000000000000000000000000000000);\n  }\n}\n"
    },
    "contracts/RedStoneBaseContracts/redstone-oracles-monorepo/packages/on-chain-relayer/contracts/mocks/LayerBankOracleAdapterV1Mock.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity ^0.8.14;\n\nimport {AuthorisedMockSignersBase} from \"@redstone-finance/evm-connector/contracts/mocks/AuthorisedMockSignersBase.sol\";\nimport {LayerBankOracleAdapterV1} from \"../custom-integrations/layerbank/LayerBankOracleAdapterV1.sol\";\n\ncontract LayerBankOracleAdapterV1Mock is LayerBankOracleAdapterV1, AuthorisedMockSignersBase {\n  error InvalidGToken(address gToken);\n\n  function getUniqueSignersThreshold() public view virtual override returns (uint8) {\n    return 2;\n  }\n\n  function getAuthorisedSignerIndex(\n    address signerAddress\n  ) public view virtual override returns (uint8) {\n    return getAuthorisedMockSignerIndex(signerAddress);\n  }\n\n  // Real implementation relies on the `.underlying()` method on gToken contract\n  function getUnderlyingAsset(address gToken) public view virtual override returns(address) {\n    if (gToken == 0x0000000000000000000000000000000000000001) {\n      return ETH_ASSET;\n    } else if (gToken == 0x0000000000000000000000000000000000000002) {\n      return 0x95CeF13441Be50d20cA4558CC0a27B601aC544E5;\n    } else {\n      revert InvalidGToken(gToken);\n    }\n  }\n}\n"
    },
    "contracts/RedStoneBaseContracts/redstone-oracles-monorepo/packages/on-chain-relayer/contracts/mocks/MentoAdapterMock.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity ^0.8.14;\n\nimport {AuthorisedMockSignersBase} from \"@redstone-finance/evm-connector/contracts/mocks/AuthorisedMockSignersBase.sol\";\nimport {MentoAdapterBase} from \"../custom-integrations/mento/MentoAdapterBase.sol\";\nimport {ISortedOracles} from \"../custom-integrations/mento/ISortedOracles.sol\";\n\ncontract MentoAdapterMock is MentoAdapterBase, AuthorisedMockSignersBase {\n  bytes32 constant SORTED_ORACLES_STORAGE_LOCATION =\n    0xffb5022e7ec148ee9291f1db3ace462efbd625c0fdffbcd0ab6d6554364a3bfd; // keccak256(\"RedStone.sortedOracles\");\n\n  function setSortedOraclesAddress(ISortedOracles sortedOracles) public {\n    assembly {\n      sstore(SORTED_ORACLES_STORAGE_LOCATION, sortedOracles)\n    }\n  }\n\n  function getSortedOracles()\n    public\n    view\n    override\n    returns (ISortedOracles sortedOracles)\n  {\n    assembly {\n      sortedOracles := sload(SORTED_ORACLES_STORAGE_LOCATION)\n    }\n  }\n\n  function getUniqueSignersThreshold() public view virtual override returns (uint8) {\n    return 2;\n  }\n\n  function getAuthorisedSignerIndex(\n    address signerAddress\n  ) public view virtual override returns (uint8) {\n    return getAuthorisedMockSignerIndex(signerAddress);\n  }\n\n  function getTokenDetailsAtIndex(\n    uint256 tokenIndex\n  ) public view virtual override returns (bytes32 dataFeedId, address tokenAddress) {\n    if (tokenIndex == 0) {\n      return (bytes32(\"BTC\"), 0xF194afDf50B03e69Bd7D057c1Aa9e10c9954E4C9);\n    } else if (tokenIndex == 1) {\n      return (bytes32(\"ETH\"), 0x874069Fa1Eb16D44d622F2e0Ca25eeA172369bC1);\n    } else {\n      revert TokenNotFoundForIndex(tokenIndex);\n    }\n  }\n\n  function getDataFeedsCount() public pure virtual override returns (uint256) {\n    return 2;\n  }\n}\n"
    },
    "contracts/RedStoneBaseContracts/redstone-oracles-monorepo/packages/on-chain-relayer/contracts/mocks/MentoAdapterMockV2.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity ^0.8.14;\n\nimport \"./MentoAdapterMock.sol\";\n\ncontract MentoAdapterMockV2 is MentoAdapterMock {\n  function getDataFeedsCount() public pure override returns (uint256) {\n    return 1;\n  }\n}\n"
    },
    "contracts/RedStoneBaseContracts/redstone-oracles-monorepo/packages/on-chain-relayer/contracts/mocks/MergedPriceFeedAdapterWithoutRoundsMock.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity ^0.8.14;\n\nimport {IRedstoneAdapter} from \"../core/IRedstoneAdapter.sol\";\nimport {AuthorisedMockSignersBase} from \"@redstone-finance/evm-connector/contracts/mocks/AuthorisedMockSignersBase.sol\";\nimport {MergedPriceFeedAdapterWithoutRounds} from \"../price-feeds/without-rounds/MergedPriceFeedAdapterWithoutRounds.sol\";\n\ncontract MergedPriceFeedAdapterWithoutRoundsMock is MergedPriceFeedAdapterWithoutRounds, AuthorisedMockSignersBase {\n  function getUniqueSignersThreshold() public view virtual override returns (uint8) {\n    return 2;\n  }\n\n  function getAuthorisedSignerIndex(address signerAddress) public view virtual override returns (uint8) {\n    return getAuthorisedMockSignerIndex(signerAddress);\n  }\n\n  function getDataFeedId() public pure virtual override returns (bytes32) {\n    return bytes32(\"BTC\");\n  }\n}\n"
    },
    "contracts/RedStoneBaseContracts/redstone-oracles-monorepo/packages/on-chain-relayer/contracts/mocks/MergedPriceFeedAdapterWithoutRoundsUpdatedMock.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity ^0.8.14;\n\nimport {MergedPriceFeedAdapterWithoutRoundsMock} from \"./MergedPriceFeedAdapterWithoutRoundsMock.sol\";\n\ncontract MergedPriceFeedAdapterWithoutRoundsUpdatedMock is MergedPriceFeedAdapterWithoutRoundsMock {\n  function version() public virtual pure override returns (uint256) {\n    return 42;\n  }\n}\n"
    },
    "contracts/RedStoneBaseContracts/redstone-oracles-monorepo/packages/on-chain-relayer/contracts/mocks/MergedPriceFeedAdapterWithRoundsMock.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity ^0.8.14;\n\nimport {IRedstoneAdapter} from \"../core/IRedstoneAdapter.sol\";\nimport {AuthorisedMockSignersBase} from \"@redstone-finance/evm-connector/contracts/mocks/AuthorisedMockSignersBase.sol\";\nimport {MergedPriceFeedAdapterWithRounds} from \"../price-feeds/with-rounds/MergedPriceFeedAdapterWithRounds.sol\";\n\ncontract MergedPriceFeedAdapterWithRoundsMock is MergedPriceFeedAdapterWithRounds, AuthorisedMockSignersBase {\n  function getUniqueSignersThreshold() public view virtual override returns (uint8) {\n    return 2;\n  }\n\n  function getAuthorisedSignerIndex(address signerAddress) public view virtual override returns (uint8) {\n    return getAuthorisedMockSignerIndex(signerAddress);\n  }\n\n  function getDataFeedId() public pure virtual override returns (bytes32) {\n    return bytes32(\"BTC\");\n  }\n}\n"
    },
    "contracts/RedStoneBaseContracts/redstone-oracles-monorepo/packages/on-chain-relayer/contracts/mocks/MergedPriceFeedAdapterWithRoundsUpdatedMock.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity ^0.8.14;\n\nimport {MergedPriceFeedAdapterWithRoundsMock} from \"./MergedPriceFeedAdapterWithRoundsMock.sol\";\n\ncontract MergedPriceFeedAdapterWithRoundsUpdatedMock is MergedPriceFeedAdapterWithRoundsMock {\n  function version() public virtual pure override returns (uint256) {\n    return 42;\n  }\n}\n"
    },
    "contracts/RedStoneBaseContracts/redstone-oracles-monorepo/packages/on-chain-relayer/contracts/mocks/PriceFeedsAdapterWithLowestRead.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity ^0.8.14;\n\nimport {AuthorisedMockSignersBase} from \"@redstone-finance/evm-connector/contracts/mocks/AuthorisedMockSignersBase.sol\";\nimport {PriceFeedsAdapterWithoutRounds} from \"../price-feeds/without-rounds/PriceFeedsAdapterWithoutRounds.sol\";\nimport {LowestGasRead} from \"../custom-integrations/LowestGasRead.sol\";\n\ncontract PriceFeedsAdapterWithLowestGasRead is PriceFeedsAdapterWithoutRounds, AuthorisedMockSignersBase, LowestGasRead {\n  function getDataFeedIds() public pure virtual override returns (bytes32[] memory dataFeedIds) {\n    dataFeedIds = new bytes32[](1);\n    dataFeedIds[0] = bytes32(\"BTC\");\n  }\n\n  function getUniqueSignersThreshold() public view virtual override returns (uint8) {\n    return 2;\n  }\n\n  function getAuthorisedSignerIndex(address signerAddress)\n    public\n    view\n    virtual\n    override\n    returns (uint8)\n  {\n    return getAuthorisedMockSignerIndex(signerAddress);\n  }\n}\n"
    },
    "contracts/RedStoneBaseContracts/redstone-oracles-monorepo/packages/on-chain-relayer/contracts/mocks/PriceFeedsAdapterWithoutRoundsMock.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity ^0.8.14;\n\nimport {AuthorisedMockSignersBase} from \"@redstone-finance/evm-connector/contracts/mocks/AuthorisedMockSignersBase.sol\";\nimport {PriceFeedsAdapterWithoutRounds} from \"../price-feeds/without-rounds/PriceFeedsAdapterWithoutRounds.sol\";\n\ncontract PriceFeedsAdapterWithoutRoundsMock is PriceFeedsAdapterWithoutRounds, AuthorisedMockSignersBase {\n  function getDataFeedIds() public pure virtual override returns (bytes32[] memory dataFeedIds) {\n    dataFeedIds = new bytes32[](1);\n    dataFeedIds[0] = bytes32(\"BTC\");\n  }\n\n  function getUniqueSignersThreshold() public view virtual override returns (uint8) {\n    return 2;\n  }\n\n  function getAuthorisedSignerIndex(address signerAddress)\n    public\n    view\n    virtual\n    override\n    returns (uint8)\n  {\n    return getAuthorisedMockSignerIndex(signerAddress);\n  }\n}\n"
    },
    "contracts/RedStoneBaseContracts/redstone-oracles-monorepo/packages/on-chain-relayer/contracts/mocks/PriceFeedsAdapterWithoutRoundsOneSignerMock.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity ^0.8.4;\n\nimport {PriceFeedsAdapterWithoutRoundsMock} from \"./PriceFeedsAdapterWithoutRoundsMock.sol\";\n\ncontract PriceFeedsAdapterWithoutRoundsOneSignerMock is PriceFeedsAdapterWithoutRoundsMock {\n  function getDataFeedIds() public pure override returns (bytes32[] memory dataFeedIds) {\n    dataFeedIds = new bytes32[](3);\n    dataFeedIds[0] = bytes32(\"BTC\");\n    dataFeedIds[1] = bytes32(\"ETH\");\n    dataFeedIds[2] = bytes32(\"AAVE\");\n  }\n\n  function getUniqueSignersThreshold() public view virtual override returns (uint8) {\n    return 1;\n  }\n}\n"
    },
    "contracts/RedStoneBaseContracts/redstone-oracles-monorepo/packages/on-chain-relayer/contracts/mocks/PriceFeedsAdapterWithRoundsMock.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity ^0.8.14;\n\nimport {AuthorisedMockSignersBase} from \"@redstone-finance/evm-connector/contracts/mocks/AuthorisedMockSignersBase.sol\";\nimport {PriceFeedsAdapterWithRounds} from \"../price-feeds/with-rounds/PriceFeedsAdapterWithRounds.sol\";\n\ncontract PriceFeedsAdapterWithRoundsMock is PriceFeedsAdapterWithRounds, AuthorisedMockSignersBase {\n  function getDataFeedIds() public  virtual pure override returns (bytes32[] memory dataFeedIds) {\n    dataFeedIds = new bytes32[](1);\n    dataFeedIds[0] = bytes32(\"BTC\");\n  }\n\n  function getUniqueSignersThreshold() public view virtual override returns (uint8) {\n    return 2;\n  }\n\n  function getAuthorisedSignerIndex(address signerAddress)\n    public\n    view\n    virtual\n    override\n    returns (uint8)\n  {\n    return getAuthorisedMockSignerIndex(signerAddress);\n  }\n}\n"
    },
    "contracts/RedStoneBaseContracts/redstone-oracles-monorepo/packages/on-chain-relayer/contracts/mocks/PriceFeedsAdapterWithRoundsOneSignerMock.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity ^0.8.4;\n\nimport {PriceFeedsAdapterWithRoundsMock} from \"./PriceFeedsAdapterWithRoundsMock.sol\";\n\ncontract PriceFeedsAdapterWithRoundsOneSignerMock is PriceFeedsAdapterWithRoundsMock {\n  function getDataFeedIds() public pure override returns (bytes32[] memory dataFeedIds) {\n    dataFeedIds = new bytes32[](3);\n    dataFeedIds[0] = bytes32(\"BTC\");\n    dataFeedIds[1] = bytes32(\"ETH\");\n    dataFeedIds[2] = bytes32(\"AAVE\");\n  }\n\n  function getMinIntervalBetweenUpdates() pure public override returns(uint256) {\n    return 0;\n  }\n\n  function getUniqueSignersThreshold() public view virtual override returns (uint8) {\n    return 1;\n  }\n}\n"
    },
    "contracts/RedStoneBaseContracts/redstone-oracles-monorepo/packages/on-chain-relayer/contracts/mocks/PriceFeedsAdataperUpdatedMock.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity ^0.8.4;\n\nimport {AuthorisedMockSignersBase} from \"@redstone-finance/evm-connector/contracts/mocks/AuthorisedMockSignersBase.sol\";\nimport {PriceFeedsAdapterWithRounds} from \"../price-feeds/with-rounds/PriceFeedsAdapterWithRounds.sol\";\n\ncontract PriceFeedsAdapterUpdatedMock is PriceFeedsAdapterWithRounds, AuthorisedMockSignersBase {\n  function getDataFeedIds() public pure virtual override returns (bytes32[] memory dataFeedIds) {\n    dataFeedIds = new bytes32[](2);\n    dataFeedIds[0] = bytes32(\"ETH\");\n    dataFeedIds[1] = bytes32(\"BTC\");\n  }\n\n  function getUniqueSignersThreshold() public view virtual override returns (uint8) {\n    return 2;\n  }\n\n  function getAuthorisedSignerIndex(address signerAddress) public view virtual override returns (uint8) {\n    signerAddress; // to avoid warnings during compilation\n    return 0;\n  }\n}\n"
    },
    "contracts/RedStoneBaseContracts/redstone-oracles-monorepo/packages/on-chain-relayer/contracts/mocks/PriceFeedUpdatedMock.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity ^0.8.4;\n\nimport {PriceFeedWithRounds} from \"../price-feeds/with-rounds/PriceFeedWithRounds.sol\";\nimport {IRedstoneAdapter} from \"../core/IRedstoneAdapter.sol\";\n\ncontract PriceFeedUpdatedMock is PriceFeedWithRounds {\n  IRedstoneAdapter private adapterAddress;\n\n  function setAdapterAddress(IRedstoneAdapter _adapterAddress) public {\n    adapterAddress = _adapterAddress;\n  }\n\n  function getDataFeedId() public view virtual override returns (bytes32) {\n    return bytes32(\"ETH\");\n  }\n\n  function getPriceFeedAdapter() public view virtual override returns (IRedstoneAdapter) {\n    return IRedstoneAdapter(0x2C31d00C1AE878F28c58B3aC0672007aECb4A124);\n  }\n}\n"
    },
    "contracts/RedStoneBaseContracts/redstone-oracles-monorepo/packages/on-chain-relayer/contracts/mocks/PriceFeedWithRoundsEthMock.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity ^0.8.14;\n\nimport {PriceFeedWithRoundsMock} from \"./PriceFeedWithRoundsMock.sol\";\n\ncontract PriceFeedWithRoundsEthMock is PriceFeedWithRoundsMock {\n  function getDataFeedId() public view virtual override returns (bytes32) {\n    return bytes32(\"ETH\");\n  }\n}\n"
    },
    "contracts/RedStoneBaseContracts/redstone-oracles-monorepo/packages/on-chain-relayer/contracts/mocks/PriceFeedWithRoundsMock.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity ^0.8.14;\n\nimport {IRedstoneAdapter} from \"../core/IRedstoneAdapter.sol\";\nimport {PriceFeedWithRounds} from \"../price-feeds/with-rounds/PriceFeedWithRounds.sol\";\n\ncontract PriceFeedWithRoundsMock is PriceFeedWithRounds {\n  IRedstoneAdapter private adapterAddress;\n\n  function setAdapterAddress(IRedstoneAdapter _adapterAddress) public {\n    adapterAddress = _adapterAddress;\n  }\n\n  function getDataFeedId() public view virtual override returns (bytes32) {\n    return bytes32(\"BTC\");\n  }\n\n  function getPriceFeedAdapter() public view virtual override returns (IRedstoneAdapter) {\n    return adapterAddress;\n  }\n}\n"
    },
    "contracts/RedStoneBaseContracts/redstone-oracles-monorepo/packages/on-chain-relayer/contracts/mocks/RedstonePrimaryProdERC7412Mock.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity ^0.8.14;\n\nimport {RedstonePrimaryProdWithoutRoundsERC7412} from \"../erc7412/RedstonePrimaryProdWithoutRoundsERC7412.sol\";\nimport {AuthorisedMockSignersBase} from \"@redstone-finance/evm-connector/contracts/mocks/AuthorisedMockSignersBase.sol\";\n\ncontract RedstonePrimaryProdERC7412Mock is RedstonePrimaryProdWithoutRoundsERC7412, AuthorisedMockSignersBase  {\n\n    function getDataFeedId() public pure override returns (bytes32) {\n        return bytes32(\"BTC\");\n    }\n\n    function getTTL() view internal override virtual returns (uint256) {\n        return 60;\n    }\n\n    function getUniqueSignersThreshold() view virtual override public returns (uint8) {\n        return 2;\n    }\n    \n    function getAuthorisedSignerIndex(address signerAddress)\n        public\n        view\n        virtual\n        override\n        returns (uint8)\n    {\n        return getAuthorisedMockSignerIndex(signerAddress);\n    }\n}\n"
    },
    "contracts/RedStoneBaseContracts/redstone-oracles-monorepo/packages/on-chain-relayer/contracts/mocks/SinglePriceFeedAdapterMock.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity ^0.8.14;\n\nimport {AuthorisedMockSignersBase} from \"@redstone-finance/evm-connector/contracts/mocks/AuthorisedMockSignersBase.sol\";\nimport {SinglePriceFeedAdapter} from \"../price-feeds/without-rounds/SinglePriceFeedAdapter.sol\";\n\ncontract SinglePriceFeedAdapterMock is SinglePriceFeedAdapter, AuthorisedMockSignersBase {\n  function getDataFeedId() public pure override returns (bytes32) {\n    return bytes32(\"BTC\");\n  }\n\n  function getUniqueSignersThreshold() public view virtual override returns (uint8) {\n    return 2;\n  }\n\n  function getAuthorisedSignerIndex(\n    address signerAddress\n  ) public view virtual override returns (uint8) {\n    return getAuthorisedMockSignerIndex(signerAddress);\n  }\n}\n"
    },
    "contracts/RedStoneBaseContracts/redstone-oracles-monorepo/packages/on-chain-relayer/contracts/mocks/SinglePriceFeedAdapterWithClearingMock.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity ^0.8.14;\n\nimport {AuthorisedMockSignersBase} from \"@redstone-finance/evm-connector/contracts/mocks/AuthorisedMockSignersBase.sol\";\nimport {SinglePriceFeedAdapterWithClearing} from \"../price-feeds/without-rounds/SinglePriceFeedAdapterWithClearing.sol\";\n\ncontract SinglePriceFeedAdapterWithClearingMock is\n  SinglePriceFeedAdapterWithClearing,\n  AuthorisedMockSignersBase\n{\n  function getDataFeedId() public pure override returns (bytes32) {\n    return bytes32(\"BTC\");\n  }\n\n  function getUniqueSignersThreshold() public view virtual override returns (uint8) {\n    return 2;\n  }\n\n  function getAuthorisedSignerIndex(\n    address signerAddress\n  ) public view virtual override returns (uint8) {\n    return getAuthorisedMockSignerIndex(signerAddress);\n  }\n}\n"
    },
    "contracts/RedStoneBaseContracts/redstone-oracles-monorepo/packages/on-chain-relayer/contracts/price-feeds/data-services/MergedPriceFeedAdapterWithoutRoundsPrimaryProd.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity ^0.8.14;\n\nimport {MergedPriceFeedAdapterWithoutRounds} from \"../without-rounds/MergedPriceFeedAdapterWithoutRounds.sol\";\n\nabstract contract MergedPriceFeedAdapterWithoutRoundsPrimaryProd is MergedPriceFeedAdapterWithoutRounds {\n  function getUniqueSignersThreshold() public view virtual override returns (uint8) {\n    return 2;\n  }\n\n  function getAuthorisedSignerIndex(\n    address signerAddress\n  ) public view virtual override returns (uint8) {\n    if (signerAddress == 0x8BB8F32Df04c8b654987DAaeD53D6B6091e3B774) { return 0; }\n    else if (signerAddress == 0xdEB22f54738d54976C4c0fe5ce6d408E40d88499) { return 1; }\n    else if (signerAddress == 0x51Ce04Be4b3E32572C4Ec9135221d0691Ba7d202) { return 2; }\n    else if (signerAddress == 0xDD682daEC5A90dD295d14DA4b0bec9281017b5bE) { return 3; }\n    else if (signerAddress == 0x9c5AE89C4Af6aA32cE58588DBaF90d18a855B6de) { return 4; }\n    else {\n      revert SignerNotAuthorised(signerAddress);\n    }\n  }\n}\n"
    },
    "contracts/RedStoneBaseContracts/redstone-oracles-monorepo/packages/on-chain-relayer/contracts/price-feeds/data-services/MergedPriceFeedAdapterWithRoundsPrimaryProd.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity ^0.8.14;\n\nimport {MergedPriceFeedAdapterWithRounds} from \"../with-rounds/MergedPriceFeedAdapterWithRounds.sol\";\n\nabstract contract MergedPriceFeedAdapterWithRoundsPrimaryProd is MergedPriceFeedAdapterWithRounds {\n  function getUniqueSignersThreshold() public view virtual override returns (uint8) {\n    return 2;\n  }\n\n  function getAuthorisedSignerIndex(\n    address signerAddress\n  ) public view virtual override returns (uint8) {\n    if (signerAddress == 0x8BB8F32Df04c8b654987DAaeD53D6B6091e3B774) { return 0; }\n    else if (signerAddress == 0xdEB22f54738d54976C4c0fe5ce6d408E40d88499) { return 1; }\n    else if (signerAddress == 0x51Ce04Be4b3E32572C4Ec9135221d0691Ba7d202) { return 2; }\n    else if (signerAddress == 0xDD682daEC5A90dD295d14DA4b0bec9281017b5bE) { return 3; }\n    else if (signerAddress == 0x9c5AE89C4Af6aA32cE58588DBaF90d18a855B6de) { return 4; }\n    else {\n      revert SignerNotAuthorised(signerAddress);\n    }\n  }\n}\n"
    },
    "contracts/RedStoneBaseContracts/redstone-oracles-monorepo/packages/on-chain-relayer/contracts/price-feeds/data-services/MergedSinglePriceFeedAdapterWithoutRoundsPrimaryProd.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity ^0.8.14;\n\nimport {MergedSinglePriceFeedAdapterWithoutRounds} from \"../without-rounds/MergedSinglePriceFeedAdapterWithoutRounds.sol\";\n\nabstract contract MergedSinglePriceFeedAdapterWithoutRoundsPrimaryProd is MergedSinglePriceFeedAdapterWithoutRounds  {\n  function getUniqueSignersThreshold() public view virtual override returns (uint8) {\n    return 3;\n  }\n\n  function getAuthorisedSignerIndex(\n    address signerAddress\n  ) public view virtual override returns (uint8) {\n    if (signerAddress == 0x8BB8F32Df04c8b654987DAaeD53D6B6091e3B774) { return 0; }\n    else if (signerAddress == 0xdEB22f54738d54976C4c0fe5ce6d408E40d88499) { return 1; }\n    else if (signerAddress == 0x51Ce04Be4b3E32572C4Ec9135221d0691Ba7d202) { return 2; }\n    else if (signerAddress == 0xDD682daEC5A90dD295d14DA4b0bec9281017b5bE) { return 3; }\n    else if (signerAddress == 0x9c5AE89C4Af6aA32cE58588DBaF90d18a855B6de) { return 4; }\n    else {\n      revert SignerNotAuthorised(signerAddress);\n    }\n  }\n\n  function getDataServiceId() public view override virtual returns (string memory) {\n      return \"redstone-primary-prod\";\n  }\n}\n"
    },
    "contracts/RedStoneBaseContracts/redstone-oracles-monorepo/packages/on-chain-relayer/contracts/price-feeds/data-services/PriceFeedsAdapterWithoutRoundsMainDemo.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity ^0.8.14;\n\nimport {PriceFeedsAdapterWithoutRounds} from \"../without-rounds/PriceFeedsAdapterWithoutRounds.sol\";\n\nabstract contract PriceFeedsAdapterWithoutRoundsMainDemo is PriceFeedsAdapterWithoutRounds {\n  function getUniqueSignersThreshold() public view virtual override returns (uint8) {\n    return 1;\n  }\n\n  function getAuthorisedSignerIndex(address signerAddress)\n    public\n    view\n    virtual\n    override\n    returns (uint8)\n  {\n    if (signerAddress == 0x0C39486f770B26F5527BBBf942726537986Cd7eb) {\n      return 0;\n    } else {\n      revert SignerNotAuthorised(signerAddress);\n    }\n  }\n}\n"
    },
    "contracts/RedStoneBaseContracts/redstone-oracles-monorepo/packages/on-chain-relayer/contracts/price-feeds/data-services/PriceFeedsAdapterWithoutRoundsPrimaryProd.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity ^0.8.14;\n\nimport {PriceFeedsAdapterWithoutRounds} from \"../without-rounds/PriceFeedsAdapterWithoutRounds.sol\";\n\nabstract contract PriceFeedsAdapterWithoutRoundsPrimaryProd is PriceFeedsAdapterWithoutRounds {\n  function getUniqueSignersThreshold() public view virtual override returns (uint8) {\n    return 2;\n  }\n\n  function getAuthorisedSignerIndex(\n    address signerAddress\n  ) public view virtual override returns (uint8) {\n    if (signerAddress == 0x8BB8F32Df04c8b654987DAaeD53D6B6091e3B774) { return 0; }\n    else if (signerAddress == 0xdEB22f54738d54976C4c0fe5ce6d408E40d88499) { return 1; }\n    else if (signerAddress == 0x51Ce04Be4b3E32572C4Ec9135221d0691Ba7d202) { return 2; }\n    else if (signerAddress == 0xDD682daEC5A90dD295d14DA4b0bec9281017b5bE) { return 3; }\n    else if (signerAddress == 0x9c5AE89C4Af6aA32cE58588DBaF90d18a855B6de) { return 4; }\n    else {\n      revert SignerNotAuthorised(signerAddress);\n    }\n  }\n}\n"
    },
    "contracts/RedStoneBaseContracts/redstone-oracles-monorepo/packages/on-chain-relayer/contracts/price-feeds/data-services/PriceFeedsAdapterWithRoundsMainDemo.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity ^0.8.14;\n\nimport {PriceFeedsAdapterWithRounds} from \"../with-rounds/PriceFeedsAdapterWithRounds.sol\";\n\nabstract contract PriceFeedsAdapterWithRoundsMainDemo is PriceFeedsAdapterWithRounds {\n  function getUniqueSignersThreshold() public view virtual override returns (uint8) {\n    return 1;\n  }\n\n  function getAuthorisedSignerIndex(\n    address signerAddress\n  ) public view virtual override returns (uint8) {\n    if (signerAddress == 0x0C39486f770B26F5527BBBf942726537986Cd7eb) {\n      return 0;\n    } else {\n      revert SignerNotAuthorised(signerAddress);\n    }\n  }\n}\n"
    },
    "contracts/RedStoneBaseContracts/redstone-oracles-monorepo/packages/on-chain-relayer/contracts/price-feeds/data-services/PriceFeedsAdapterWithRoundsPrimaryProd.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity ^0.8.14;\n\nimport {PriceFeedsAdapterWithRounds} from \"../with-rounds/PriceFeedsAdapterWithRounds.sol\";\n\nabstract contract PriceFeedsAdapterWithRoundsPrimaryProd is PriceFeedsAdapterWithRounds {\n  function getUniqueSignersThreshold() public view virtual override returns (uint8) {\n    return 2;\n  }\n\n  function getAuthorisedSignerIndex(\n    address signerAddress\n  ) public view virtual override returns (uint8) {\n    if (signerAddress == 0x8BB8F32Df04c8b654987DAaeD53D6B6091e3B774) { return 0; }\n    else if (signerAddress == 0xdEB22f54738d54976C4c0fe5ce6d408E40d88499) { return 1; }\n    else if (signerAddress == 0x51Ce04Be4b3E32572C4Ec9135221d0691Ba7d202) { return 2; }\n    else if (signerAddress == 0xDD682daEC5A90dD295d14DA4b0bec9281017b5bE) { return 3; }\n    else if (signerAddress == 0x9c5AE89C4Af6aA32cE58588DBaF90d18a855B6de) { return 4; }\n    else {\n      revert SignerNotAuthorised(signerAddress);\n    }\n  }\n}\n"
    },
    "contracts/RedStoneBaseContracts/redstone-oracles-monorepo/packages/on-chain-relayer/contracts/price-feeds/data-services/VSTPriceFeedsAdapter.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity ^0.8.14;\n\nimport {SinglePriceFeedAdapter} from \"../without-rounds/SinglePriceFeedAdapter.sol\";\n\ncontract VSTPriceFeedsAdapter is SinglePriceFeedAdapter {\n  uint256 internal constant BIT_MASK_TO_CHECK_CIRCUIT_BREAKER_FLAG = 0x0000000000000000000000000100000000000000000000000000000000000000;\n\n  error InvalidSignersCount(uint256 signersCount);\n  error CircuitBreakerTripped();\n\n  function getDataFeedId() public pure override returns (bytes32) {\n    return bytes32(\"VST\");\n  }\n\n  function getUniqueSignersThreshold() public view virtual override returns (uint8) {\n    return 2; // 2 out of 3\n  }\n\n  function aggregateValues(uint256[] memory values) public pure override returns (uint256) {\n    if (values.length != 2) {\n      revert InvalidSignersCount(values.length);\n    }\n\n    _checkCircuitBreaker(values[0]);\n    _checkCircuitBreaker(values[1]);\n\n    return (values[0] + values[1]) / 2;\n  }\n\n  function _checkCircuitBreaker(uint256 value) internal pure {\n    if (value & BIT_MASK_TO_CHECK_CIRCUIT_BREAKER_FLAG > 0) {\n      revert CircuitBreakerTripped();\n    }\n  }\n\n  function getAuthorisedSignerIndex(\n    address signerAddress\n  ) public view virtual override returns (uint8) {\n    if (signerAddress == 0xf7a873ff07E1d021ae808a28e6862f821148c789) {\n      return 0;\n    } else if (signerAddress == 0x827Cc644d3f33d55075354875A961aC8B9EB7Cc8) {\n      return 1;\n    } else if (signerAddress == 0x1C31b3eA83F48A6E550938d295893514A9e99Eca) {\n      return 2;\n    } else {\n      revert SignerNotAuthorised(signerAddress);\n    }\n  }\n}\n"
    },
    "contracts/RedStoneBaseContracts/redstone-oracles-monorepo/packages/on-chain-relayer/contracts/price-feeds/data-services/VSTPriceFeedsAdapterWithoutRoundsMainDemo.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity ^0.8.14;\n\nimport {SinglePriceFeedAdapter} from \"../without-rounds/SinglePriceFeedAdapter.sol\";\n\ncontract VSTPriceFeedsAdapterWithoutRoundsMainDemo is SinglePriceFeedAdapter {\n  function getDataFeedId() public pure override returns (bytes32) {\n    return bytes32(\"VST\");\n  }\n\n  function getUniqueSignersThreshold() public view virtual override returns (uint8) {\n    return 1;\n  }\n\n  function getAuthorisedSignerIndex(address signerAddress)\n    public\n    view\n    virtual\n    override\n    returns (uint8)\n  {\n    if (signerAddress == 0x0C39486f770B26F5527BBBf942726537986Cd7eb) {\n      return 0;\n    } else {\n      revert SignerNotAuthorised(signerAddress);\n    }\n  }\n}\n"
    },
    "contracts/RedStoneBaseContracts/redstone-oracles-monorepo/packages/on-chain-relayer/contracts/price-feeds/interfaces/IPriceFeed.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity ^0.8.14;\n\nimport {AggregatorV3Interface} from \"@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol\";\nimport {IPriceFeedLegacy} from \"./IPriceFeedLegacy.sol\";\n\n/**\n * @title Complete price feed interface\n * @author The Redstone Oracles team\n * @dev All required public functions that must be implemented\n * by each Redstone PriceFeed contract\n */\ninterface IPriceFeed is IPriceFeedLegacy, AggregatorV3Interface {\n  /**\n   * @notice Returns data feed identifier for the PriceFeed contract\n   * @return dataFeedId The identifier of the data feed\n   */\n  function getDataFeedId() external view returns (bytes32);\n}\n"
    },
    "contracts/RedStoneBaseContracts/redstone-oracles-monorepo/packages/on-chain-relayer/contracts/price-feeds/interfaces/IPriceFeedLegacy.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity ^0.8.14;\n\n/**\n * @title Interface with the old Chainlink Price Feed functions\n * @author The Redstone Oracles team\n * @dev There are some projects (e.g. gmx-contracts) that still\n * rely on some legacy functions\n */\ninterface IPriceFeedLegacy {\n  /**\n   * @notice Old Chainlink function for getting the number of latest round\n   * @return latestRound The number of the latest update round\n   */\n  function latestRound() external view returns (uint80);\n\n  \n  /**\n   * @notice Old Chainlink function for getting the latest successfully reported value\n   * @return latestAnswer The latest successfully reported value\n   */\n  function latestAnswer() external view returns (int256);\n}\n"
    },
    "contracts/RedStoneBaseContracts/redstone-oracles-monorepo/packages/on-chain-relayer/contracts/price-feeds/MergedPriceFeedAdapterCommon.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.14;\nimport {IRedstoneAdapter} from \"../core/IRedstoneAdapter.sol\";\nimport {SafeCast} from \"@openzeppelin/contracts/utils/math/SafeCast.sol\";\n\nabstract contract MergedPriceFeedAdapterCommon {\n  event AnswerUpdated(int256 indexed current, uint256 indexed roundId, uint256 updatedAt);\n\n  error CannotUpdateMoreThanOneDataFeed();\n\n  function getPriceFeedAdapter() public view virtual returns (IRedstoneAdapter) {\n    return IRedstoneAdapter(address(this));\n  }\n\n  function aggregator() public view virtual returns (address) {\n    return address(getPriceFeedAdapter());\n  }\n}\n"
    },
    "contracts/RedStoneBaseContracts/redstone-oracles-monorepo/packages/on-chain-relayer/contracts/price-feeds/PriceFeedBase.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.14;\n\nimport {Initializable} from \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\nimport {IRedstoneAdapter} from \"../core/IRedstoneAdapter.sol\";\nimport {IPriceFeed} from \"./interfaces/IPriceFeed.sol\";\n\n/**\n * @title Main logic of the price feed contract\n * @author The Redstone Oracles team\n * @dev Implementation of common functions for the PriceFeed contract\n * that queries data from the specified PriceFeedAdapter\n * \n * It can be used by projects that have already implemented with Chainlink-like\n * price feeds and would like to minimise changes in their existing codebase.\n * \n * If you are flexible, it's much better (and cheaper in terms of gas) to query\n * the PriceFeedAdapter contract directly\n */\nabstract contract PriceFeedBase is IPriceFeed, Initializable {\n  uint256 internal constant INT256_MAX = uint256(type(int256).max);\n\n  error UnsafeUintToIntConversion(uint256 value);\n\n  /**\n   * @dev Helpful function for upgradable contracts\n   */\n  function initialize() public virtual initializer {\n    // We don't have storage variables, but we keep this function\n    // Because it is used for contract setup in upgradable contracts\n  }\n\n  /**\n   * @notice Returns data feed identifier for the PriceFeed contract\n   * @return dataFeedId The identifier of the data feed\n   */\n  function getDataFeedId() public view virtual returns (bytes32);\n\n  /**\n   * @notice Returns the address of the price feed adapter\n   * @return address The address of the price feed adapter\n   */\n  function getPriceFeedAdapter() public view virtual returns (IRedstoneAdapter);\n\n\n  /**\n   * @notice Returns the number of decimals for the price feed\n   * @dev By default, RedStone uses 8 decimals for data feeds\n   * @return decimals The number of decimals in the price feed values\n   */\n  function decimals() public virtual pure override returns (uint8) {\n    return 8;\n  }\n\n\n  /**\n   * @notice Description of the Price Feed\n   * @return description\n   */\n  function description() public view virtual override returns (string memory) {\n    return \"Redstone Price Feed\";\n  }\n\n  /**\n   * @notice Version of the Price Feed\n   * @dev Currently it has no specific motivation and was added\n   * only to be compatible with the Chainlink interface\n   * @return version\n   */\n  function version() public virtual pure override returns (uint256) {\n    return 1;\n  }\n\n\n  /**\n   * @notice Returns details of the latest successful update round\n   * @dev It uses few helpful functions to abstract logic of getting\n   * latest round id and value\n   * @return roundId The number of the latest round\n   * @return answer The latest reported value\n   * @return startedAt Block timestamp when the latest successful round started\n   * @return updatedAt Block timestamp of the latest successful round\n   * @return answeredInRound The number of the latest round\n   */\n  function latestRoundData()\n    public\n    view\n    override\n    virtual\n    returns (\n      uint80 roundId,\n      int256 answer,\n      uint256 startedAt,\n      uint256 updatedAt,\n      uint80 answeredInRound\n    )\n  {\n    roundId = latestRound();\n    answer = latestAnswer();\n\n    uint256 blockTimestamp = getPriceFeedAdapter().getBlockTimestampFromLatestUpdate();\n\n    // These values are equal after chainlinks OCR update\n    startedAt = blockTimestamp;\n    updatedAt = blockTimestamp;\n\n    // We want to be compatible with Chainlink's interface\n    // And in our case the roundId is always equal to answeredInRound\n    answeredInRound = roundId;\n  }\n\n  /**\n   * @notice Old Chainlink function for getting the latest successfully reported value\n   * @return latestAnswer The latest successfully reported value\n   */\n  function latestAnswer() public virtual view returns (int256) {\n    bytes32 dataFeedId = getDataFeedId();\n\n    uint256 uintAnswer = getPriceFeedAdapter().getValueForDataFeed(dataFeedId);\n\n    if (uintAnswer > INT256_MAX) {\n      revert UnsafeUintToIntConversion(uintAnswer);\n    }\n\n    return int256(uintAnswer);\n  }\n\n  /**\n   * @notice Old Chainlink function for getting the number of latest round\n   * @return latestRound The number of the latest update round\n   */\n  function latestRound() public view virtual returns (uint80);\n}\n"
    },
    "contracts/RedStoneBaseContracts/redstone-oracles-monorepo/packages/on-chain-relayer/contracts/price-feeds/PriceFeedsAdapterBase.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity ^0.8.14;\n\nimport {Initializable} from \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\nimport {RedstoneAdapterBase} from \"../core/RedstoneAdapterBase.sol\";\n\n/**\n * @title Common logic of the price feeds adapter contracts\n * @author The Redstone Oracles team\n */\nabstract contract PriceFeedsAdapterBase is RedstoneAdapterBase, Initializable {\n\n  /**\n   * @dev Helpful function for upgradable contracts\n   */\n  function initialize() public virtual initializer {\n    // We don't have storage variables, but we keep this function\n    // Because it is used for contract setup in upgradable contracts\n  }\n\n  /**\n   * @dev This function is virtual and may contain additional logic in the derived contract\n   * E.g. it can check if the updating conditions are met (e.g. if at least one\n   * value is deviated enough)\n   * @param dataFeedIdsArray Array of all data feeds identifiers\n   * @param values The reported values that are validated and reported\n   */\n  function _validateAndUpdateDataFeedsValues(\n    bytes32[] memory dataFeedIdsArray,\n    uint256[] memory values\n  ) internal virtual override {\n    for (uint256 i = 0; i < dataFeedIdsArray.length;) {\n      _validateAndUpdateDataFeedValue(dataFeedIdsArray[i], values[i]);\n      unchecked { i++; } // reduces gas costs\n    }\n  }\n\n  /**\n   * @dev Helpful virtual function for handling value validation and saving in derived\n   * Price Feed Adapters contracts \n   * @param dataFeedId The data feed identifier\n   * @param dataFeedValue Proposed value for the data feed\n   */\n  function _validateAndUpdateDataFeedValue(bytes32 dataFeedId, uint256 dataFeedValue) internal virtual;\n}\n"
    },
    "contracts/RedStoneBaseContracts/redstone-oracles-monorepo/packages/on-chain-relayer/contracts/price-feeds/with-rounds/MergedPriceFeedAdapterWithRounds.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity ^0.8.14;\n\nimport {PriceFeedBase, PriceFeedWithRounds} from \"./PriceFeedWithRounds.sol\";\nimport {PriceFeedsAdapterBase, PriceFeedsAdapterWithRounds} from \"./PriceFeedsAdapterWithRounds.sol\";\nimport {IRedstoneAdapter} from \"../../core/IRedstoneAdapter.sol\";\nimport {MergedPriceFeedAdapterCommon} from \"../MergedPriceFeedAdapterCommon.sol\";\nimport {SafeCast} from \"@openzeppelin/contracts/utils/math/SafeCast.sol\";\n\nabstract contract MergedPriceFeedAdapterWithRounds is\n  MergedPriceFeedAdapterCommon,\n  PriceFeedWithRounds,\n  PriceFeedsAdapterWithRounds\n{\n  function initialize() public virtual override(PriceFeedBase, PriceFeedsAdapterBase) initializer {\n    // We don't have storage variables, but we keep this function\n    // Because it is used for contract setup in upgradable contracts\n  }\n\n  function getPriceFeedAdapter() public view virtual override(MergedPriceFeedAdapterCommon, PriceFeedBase) returns (IRedstoneAdapter) {\n    return super.getPriceFeedAdapter();\n  }\n\n  function getDataFeedIds() public view virtual override returns (bytes32[] memory dataFeedIds) {\n    dataFeedIds = new bytes32[](1);\n    dataFeedIds[0] = getDataFeedId();\n  }\n\n  function getDataFeedIndex(bytes32 dataFeedId) public view virtual override returns (uint256) {\n    if (dataFeedId == getDataFeedId()) {\n      return 0;\n    } else {\n      revert DataFeedIdNotFound(dataFeedId);\n    }\n  }\n\n  function _emitEventAfterSingleValueUpdate(uint256 newValue) internal virtual {\n    emit AnswerUpdated(SafeCast.toInt256(newValue), getLatestRoundId(), block.timestamp);\n  }\n\n  function _validateAndUpdateDataFeedsValues(\n    bytes32[] memory dataFeedIdsArray,\n    uint256[] memory values\n  ) internal virtual override {\n    if (dataFeedIdsArray.length != 1 || values.length != 1) {\n      revert CannotUpdateMoreThanOneDataFeed();\n    }\n    PriceFeedsAdapterWithRounds._validateAndUpdateDataFeedsValues(dataFeedIdsArray, values);\n    _emitEventAfterSingleValueUpdate(values[0]);\n  }\n}\n"
    },
    "contracts/RedStoneBaseContracts/redstone-oracles-monorepo/packages/on-chain-relayer/contracts/price-feeds/with-rounds/PriceFeedsAdapterWithRounds.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity ^0.8.14;\n\nimport {PriceFeedsAdapterBase} from \"../PriceFeedsAdapterBase.sol\";\n\n/**\n * @title Price feeds adapter contract with rounds support\n * @author The Redstone Oracles team\n * @dev This contract is abstract. The actual contract instance\n * must implement the following functions:\n * - getDataFeedIds\n * - getUniqueSignersThreshold\n * - getAuthorisedSignerIndex\n *\n * We also recommend to override `getDataFeedIndex` function with hardcoded\n * values, as it can significantly reduce gas usage\n */\nabstract contract PriceFeedsAdapterWithRounds is PriceFeedsAdapterBase {\n  bytes32 constant VALUES_MAPPING_STORAGE_LOCATION = 0x4dd0c77efa6f6d590c97573d8c70b714546e7311202ff7c11c484cc841d91bfc; // keccak256(\"RedStone.oracleValuesMapping\");\n  bytes32 constant ROUND_TIMESTAMPS_MAPPING_STORAGE_LOCATION = 0x207e00944d909d1224f0c253d58489121d736649f8393199f55eecf4f0cf3eb0; // keccak256(\"RedStone.roundTimestampMapping\");\n  bytes32 constant LATEST_ROUND_ID_STORAGE_LOCATION = 0xc68d7f1ee07d8668991a8951e720010c9d44c2f11c06b5cac61fbc4083263938; // keccak256(\"RedStone.latestRoundId\");\n\n  error RoundNotFound(uint256 roundId);\n\n  /**\n   * @dev Saved new round data to the storage\n   * @param dataFeedIdsArray Array of all data feeds identifiers\n   * @param values The reported values that are validated and reported\n   */\n  function _validateAndUpdateDataFeedsValues(\n    bytes32[] memory dataFeedIdsArray,\n    uint256[] memory values\n  ) internal virtual override {\n    _incrementLatestRoundId();\n    _updatePackedTimestampsForLatestRound();\n\n    for (uint256 i = 0; i < dataFeedIdsArray.length;) {\n      _validateAndUpdateDataFeedValue(dataFeedIdsArray[i], values[i]);\n      unchecked { i++; } // reduces gas costs\n    }\n  }\n\n  /**\n   * @dev Helpful virtual function for handling value validation and updating\n   * @param dataFeedId The data feed identifier\n   * @param dataFeedValue Proposed value for the data feed\n   */\n  function _validateAndUpdateDataFeedValue(bytes32 dataFeedId, uint256 dataFeedValue) internal virtual override {\n    validateDataFeedValueOnWrite(dataFeedId, dataFeedValue);\n    bytes32 locationInStorage = _getValueLocationInStorage(dataFeedId, getLatestRoundId());\n    assembly {\n      sstore(locationInStorage, dataFeedValue)\n    }\n  }\n\n  /**\n   * @dev [HIGH RISK] Returns the value for a given data feed from the latest round\n   * without validation. Important! Using this function instead of `getValueForDataFeed`\n   * may cause significant risk for your smart contracts\n   * @param dataFeedId The data feed identifier\n   * @return dataFeedValue Unvalidated value of the latest successful update\n   */\n  function getValueForDataFeedUnsafe(bytes32 dataFeedId) public view override returns (uint256 dataFeedValue) {\n    return getValueForDataFeedAndRound(dataFeedId, getLatestRoundId());\n  }\n\n  /**\n   * @dev [HIGH RISK] Returns value for the requested data feed from the given round\n   * without validation.\n   * @param dataFeedId The data feed identifier\n   * @param roundId The number of the requested round\n   * @return dataFeedValue value for the requested data feed from the given round\n   */\n  function getValueForDataFeedAndRound(bytes32 dataFeedId, uint256 roundId) public view returns (uint256 dataFeedValue) {\n    bytes32 locationInStorage = _getValueLocationInStorage(dataFeedId, roundId);\n    assembly {\n      dataFeedValue := sload(locationInStorage)\n    }\n  }\n\n\n  /**\n   * @notice Returns data from the latest successful round\n   * @return latestRoundId\n   * @return latestRoundDataTimestamp\n   * @return latestRoundBlockTimestamp\n   */\n  function getLatestRoundParams() public view returns ( uint256 latestRoundId, uint128 latestRoundDataTimestamp, uint128 latestRoundBlockTimestamp) {\n    latestRoundId = getLatestRoundId();\n    uint256 packedRoundTimestamps = getPackedTimestampsForRound(latestRoundId);\n    (latestRoundDataTimestamp, latestRoundBlockTimestamp) = _unpackTimestamps(\n      packedRoundTimestamps\n    );\n  }\n\n\n  /**\n   * @notice Returns details for the given round and data feed\n   * @param dataFeedId Requested data feed\n   * @param roundId Requested round identifier\n   * @return dataFeedValue\n   * @return roundDataTimestamp\n   * @return roundBlockTimestamp\n   */\n  function getRoundDataFromAdapter(bytes32 dataFeedId, uint256 roundId) public view returns (uint256 dataFeedValue, uint128 roundDataTimestamp, uint128 roundBlockTimestamp) {\n    if (roundId > getLatestRoundId() || roundId == 0) {\n      revert RoundNotFound(roundId);\n    }\n\n    dataFeedValue = getValueForDataFeedAndRound(dataFeedId, roundId);\n    validateDataFeedValueOnRead(dataFeedId, dataFeedValue);\n    uint256 packedRoundTimestamps = getPackedTimestampsForRound(roundId);\n    (roundDataTimestamp, roundBlockTimestamp) = _unpackTimestamps(packedRoundTimestamps);\n  }\n\n\n  /**\n   * @dev Helpful function for getting storage location for requested value\n   * @param dataFeedId Requested data feed identifier\n   * @param roundId Requested round number\n   * @return locationInStorage\n   */\n  function _getValueLocationInStorage(bytes32 dataFeedId, uint256 roundId) private pure returns (bytes32) {\n    return keccak256(abi.encode(dataFeedId, roundId, VALUES_MAPPING_STORAGE_LOCATION));\n  }\n\n\n  /**\n   * @dev Helpful function for getting storage location for round timestamps\n   * @param roundId Requested round number\n   * @return locationInStorage\n   */\n  function _getRoundTimestampsLocationInStorage(uint256 roundId) private pure returns (bytes32) {\n    return keccak256(abi.encode(roundId, ROUND_TIMESTAMPS_MAPPING_STORAGE_LOCATION));\n  }\n\n\n  /**\n   * @notice Returns latest successful round number\n   * @return latestRoundId\n   */\n  function getLatestRoundId() public view returns (uint256 latestRoundId) {\n    assembly {\n      latestRoundId := sload(LATEST_ROUND_ID_STORAGE_LOCATION)\n    }\n  }\n\n  /**\n   * @dev Helpful function for incrementing the latest round number by 1 in\n   * the contract storage\n   */\n  function _incrementLatestRoundId() private {\n    uint256 latestRoundId = getLatestRoundId();\n    assembly {\n      sstore(LATEST_ROUND_ID_STORAGE_LOCATION, add(latestRoundId, 1))\n    }\n  }\n\n  /**\n   * @notice Returns timestamps related to the given round packed into one number\n   * @param roundId Requested round number\n   * @return roundTimestamps\n   */\n  function getPackedTimestampsForRound(uint256 roundId) public view returns (uint256 roundTimestamps) {\n    bytes32 locationInStorage = _getRoundTimestampsLocationInStorage(roundId);\n    assembly {\n      roundTimestamps := sload(locationInStorage)\n    }\n  }\n\n\n  /**\n   * @dev Saves packed timestamps (data and block.timestamp) in the contract storage\n   */\n  function _updatePackedTimestampsForLatestRound() private {\n    uint256 packedTimestamps = getPackedTimestampsFromLatestUpdate();\n    uint256 latestRoundId = getLatestRoundId();\n    bytes32 locationInStorage = _getRoundTimestampsLocationInStorage(latestRoundId);\n    assembly {\n      sstore(locationInStorage, packedTimestamps)\n    }\n  }\n}\n"
    },
    "contracts/RedStoneBaseContracts/redstone-oracles-monorepo/packages/on-chain-relayer/contracts/price-feeds/with-rounds/PriceFeedWithRounds.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity ^0.8.14;\n\nimport {PriceFeedsAdapterWithRounds} from \"./PriceFeedsAdapterWithRounds.sol\";\nimport {PriceFeedBase} from \"../PriceFeedBase.sol\";\n\n/**\n * @title Implementation of a price feed contract with rounds support\n * @author The Redstone Oracles team\n * @dev This contract is abstract. The actual contract instance\n * must implement the following functions:\n * - getDataFeedId\n * - getPriceFeedAdapter\n */\nabstract contract PriceFeedWithRounds is PriceFeedBase {\n  uint256 internal constant UINT80_MAX = uint256(type(uint80).max);\n\n  error UnsafeUint256ToUint80Conversion(uint256 value);\n\n  function getPriceFeedAdapterWithRounds() public view returns(PriceFeedsAdapterWithRounds) {\n    return PriceFeedsAdapterWithRounds(address(getPriceFeedAdapter()));\n  }\n\n  /**\n   * @notice Old Chainlink function for getting the number of latest round\n   * @return latestRound The number of the latest successful round\n   */\n  function latestRound() public view override returns (uint80) {\n    uint256 latestRoundUint256 = getPriceFeedAdapterWithRounds().getLatestRoundId();\n\n    if (latestRoundUint256 > UINT80_MAX) {\n      revert UnsafeUint256ToUint80Conversion(latestRoundUint256);\n    }\n\n    return uint80(latestRoundUint256);\n  }\n\n  /**\n   * @notice Returns details for the given round\n   * @param roundId Requested round identifier\n   */\n  function getRoundData(uint80 requestedRoundId) public view override returns (uint80 roundId, int256 answer, uint256 startedAt, uint256 updatedAt, uint80 answeredInRound) {\n    (uint256 dataFeedValue, uint128 roundDataTimestamp, uint128 roundBlockTimestamp) = getPriceFeedAdapterWithRounds().getRoundDataFromAdapter(\n      getDataFeedId(),\n      requestedRoundId\n    );\n    roundId = requestedRoundId;\n\n    if (dataFeedValue > INT256_MAX) {\n      revert UnsafeUintToIntConversion(dataFeedValue);\n    }\n\n    answer = int256(dataFeedValue);\n    startedAt = roundDataTimestamp / 1000; // convert to seconds\n    updatedAt = roundBlockTimestamp;\n\n    // We want to be compatible with Chainlink's interface\n    // And in our case the roundId is always equal to answeredInRound\n    answeredInRound = requestedRoundId;\n  }\n}\n"
    },
    "contracts/RedStoneBaseContracts/redstone-oracles-monorepo/packages/on-chain-relayer/contracts/price-feeds/without-rounds/MergedPriceFeedAdapterWithoutRounds.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity ^0.8.14;\n\nimport {PriceFeedsAdapterBase, PriceFeedsAdapterWithoutRounds} from \"./PriceFeedsAdapterWithoutRounds.sol\";\nimport {PriceFeedBase, PriceFeedWithoutRounds} from \"./PriceFeedWithoutRounds.sol\";\nimport {IRedstoneAdapter} from \"../../core/IRedstoneAdapter.sol\";\nimport {MergedPriceFeedAdapterCommon} from \"../MergedPriceFeedAdapterCommon.sol\";\nimport {SafeCast} from \"@openzeppelin/contracts/utils/math/SafeCast.sol\";\n\nabstract contract MergedPriceFeedAdapterWithoutRounds is\n  MergedPriceFeedAdapterCommon,\n  PriceFeedsAdapterWithoutRounds,\n  PriceFeedWithoutRounds\n{\n\n  function initialize() public override(PriceFeedBase, PriceFeedsAdapterBase) initializer {\n    // We don't have storage variables, but we keep this function\n    // Because it is used for contract setup in upgradable contracts\n  }\n\n  function getPriceFeedAdapter() public view virtual override(MergedPriceFeedAdapterCommon, PriceFeedBase) returns (IRedstoneAdapter) {\n    return super.getPriceFeedAdapter();\n  }\n\n  function getDataFeedIds() public view virtual override returns (bytes32[] memory dataFeedIds) {\n    dataFeedIds = new bytes32[](1);\n    dataFeedIds[0] = getDataFeedId();\n  }\n\n  function getDataFeedIndex(bytes32 dataFeedId) public view virtual override returns (uint256) {\n    if (dataFeedId == getDataFeedId()) {\n      return 0;\n    } else {\n      revert DataFeedIdNotFound(dataFeedId);\n    }\n  }\n\n  function _emitEventAfterSingleValueUpdate(uint256 newValue) internal virtual {\n    emit AnswerUpdated(SafeCast.toInt256(newValue), latestRound(), block.timestamp);\n  }\n\n  function _validateAndUpdateDataFeedsValues(\n    bytes32[] memory dataFeedIdsArray,\n    uint256[] memory values\n  ) internal virtual override {\n    if (dataFeedIdsArray.length != 1 || values.length != 1) {\n      revert CannotUpdateMoreThanOneDataFeed();\n    }\n    _validateAndUpdateDataFeedValue(dataFeedIdsArray[0], values[0]);\n    _emitEventAfterSingleValueUpdate(values[0]);\n  }\n}\n"
    },
    "contracts/RedStoneBaseContracts/redstone-oracles-monorepo/packages/on-chain-relayer/contracts/price-feeds/without-rounds/MergedSinglePriceFeedAdapterWithoutRounds.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.14;\n\nimport {SinglePriceFeedAdapter} from \"./SinglePriceFeedAdapter.sol\";\nimport {PriceFeedsAdapterBase} from \"./PriceFeedsAdapterWithoutRounds.sol\";\nimport {PriceFeedBase, PriceFeedWithoutRounds} from \"./PriceFeedWithoutRounds.sol\";\nimport {IRedstoneAdapter} from \"../../core/IRedstoneAdapter.sol\";\nimport {MergedPriceFeedAdapterCommon} from \"../MergedPriceFeedAdapterCommon.sol\";\nimport {SafeCast} from \"@openzeppelin/contracts/utils/math/SafeCast.sol\";\n\nabstract contract MergedSinglePriceFeedAdapterWithoutRounds is\n  MergedPriceFeedAdapterCommon,\n  SinglePriceFeedAdapter,\n  PriceFeedWithoutRounds\n{\n\n  function getDataFeedId() public view virtual override(SinglePriceFeedAdapter, PriceFeedBase) returns (bytes32);\n\n  function initialize() public override(PriceFeedBase, PriceFeedsAdapterBase) initializer {\n    // We don't have storage variables, but we keep this function\n    // Because it is used for contract setup in upgradable contracts\n  }\n\n  function getPriceFeedAdapter() public view virtual override(MergedPriceFeedAdapterCommon, PriceFeedBase) returns (IRedstoneAdapter) {\n    return super.getPriceFeedAdapter();\n  }\n\n  function _emitEventAfterSingleValueUpdate(uint256 newValue) internal virtual {\n    emit AnswerUpdated(SafeCast.toInt256(newValue), latestRound(), block.timestamp);\n  }\n\n  function _validateAndUpdateDataFeedsValues(\n    bytes32[] memory dataFeedIdsArray,\n    uint256[] memory values\n  ) internal virtual override {\n    if (dataFeedIdsArray.length != 1 || values.length != 1) {\n      revert CannotUpdateMoreThanOneDataFeed();\n    }\n    _validateAndUpdateDataFeedValue(dataFeedIdsArray[0], values[0]);\n    _emitEventAfterSingleValueUpdate(values[0]);\n  }\n}\n"
    },
    "contracts/RedStoneBaseContracts/redstone-oracles-monorepo/packages/on-chain-relayer/contracts/price-feeds/without-rounds/PriceFeedsAdapterWithoutRounds.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity ^0.8.14;\n\nimport {PriceFeedsAdapterBase} from \"../PriceFeedsAdapterBase.sol\";\n\n/**\n * @title Implementation of a price feeds adapter without rounds support\n * @author The Redstone Oracles team\n * @dev This contract is abstract, the following functions should be\n * implemented in the actual contract before deployment:\n * - getDataFeedIds\n * - getUniqueSignersThreshold\n * - getAuthorisedSignerIndex\n * \n * We also recommend to override `getDataFeedIndex` function with hardcoded\n * values, as it can significantly reduce gas usage\n */\nabstract contract PriceFeedsAdapterWithoutRounds is PriceFeedsAdapterBase {\n  bytes32 constant VALUES_MAPPING_STORAGE_LOCATION = 0x4dd0c77efa6f6d590c97573d8c70b714546e7311202ff7c11c484cc841d91bfc; // keccak256(\"RedStone.oracleValuesMapping\");\n\n  /**\n   * @dev Helpful virtual function for handling value validation and saving\n   * @param dataFeedId The data feed identifier\n   * @param dataFeedValue Proposed value for the data feed\n   */\n  function _validateAndUpdateDataFeedValue(bytes32 dataFeedId, uint256 dataFeedValue) internal override virtual {\n    validateDataFeedValueOnWrite(dataFeedId, dataFeedValue);\n    bytes32 locationInStorage = _getValueLocationInStorage(dataFeedId);\n    assembly {\n      sstore(locationInStorage, dataFeedValue)\n    }\n  }\n\n  /**\n   * @dev [HIGH RISK] Returns the latest value for a given data feed without validation\n   * Important! Using this function instead of `getValueForDataFeed` may cause\n   * significant risk for your smart contracts\n   * @param dataFeedId The data feed identifier\n   * @return dataFeedValue Unvalidated value of the latest successful update\n   */\n  function getValueForDataFeedUnsafe(bytes32 dataFeedId) public view  virtual override returns (uint256 dataFeedValue) {\n    bytes32 locationInStorage = _getValueLocationInStorage(dataFeedId);\n    assembly {\n      dataFeedValue := sload(locationInStorage)\n    }\n  }\n\n  /**\n   * @dev Helpful function for getting storage location for the requested data feed\n   * @param dataFeedId Requested data feed identifier\n   * @return locationInStorage\n   */\n  function _getValueLocationInStorage(bytes32 dataFeedId) private pure returns (bytes32) {\n    return keccak256(abi.encode(dataFeedId, VALUES_MAPPING_STORAGE_LOCATION));\n  }\n}\n"
    },
    "contracts/RedStoneBaseContracts/redstone-oracles-monorepo/packages/on-chain-relayer/contracts/price-feeds/without-rounds/PriceFeedWithoutRounds.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.14;\n\nimport {PriceFeedBase} from \"../PriceFeedBase.sol\";\n\n/**\n * @title Implementation of a price feed contract without rounds support\n * @author The Redstone Oracles team\n * @dev This contract is abstract. The actual contract instance\n * must implement the following functions:\n * - getDataFeedId\n * - getPriceFeedAdapter\n */\nabstract contract PriceFeedWithoutRounds is PriceFeedBase {\n  uint80 constant DEFAULT_ROUND = 1;\n\n  error GetRoundDataCanBeOnlyCalledWithLatestRound(uint80 requestedRoundId);\n\n  /**\n   * @dev We always return 1, since we do not support rounds in this contract\n   */\n  function latestRound() public pure override returns (uint80) {\n    return DEFAULT_ROUND;\n  }\n  \n  /**\n   * @dev There are possible use cases that some contracts don't need values from old rounds\n   * but still rely on `getRoundData` or `latestRounud` functions\n   */\n  function getRoundData(uint80 requestedRoundId) public view override returns (uint80 roundId, int256 answer, uint256 startedAt, uint256 updatedAt, uint80 answeredInRound) {\n    if (requestedRoundId != latestRound()) {\n      revert GetRoundDataCanBeOnlyCalledWithLatestRound(requestedRoundId);\n    }\n    return latestRoundData();\n  }\n}\n"
    },
    "contracts/RedStoneBaseContracts/redstone-oracles-monorepo/packages/on-chain-relayer/contracts/price-feeds/without-rounds/SinglePriceFeedAdapter.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity ^0.8.14;\n\nimport {PriceFeedsAdapterBase} from \"../PriceFeedsAdapterBase.sol\";\n\n/**\n * @title Price feed adapter for one specific data feed without rounds support\n * @author The Redstone Oracles team\n * @dev This version works only with a single data feed. It's abstract and\n * the following functions should be implemented in the actual contract\n * before deployment:\n * - getDataFeedId\n * - getUniqueSignersThreshold\n * - getAuthorisedSignerIndex\n * \n * This contract stores the value along with timestamps in a single storage slot\n * 32 bytes = 6 bytes (Data timestamp ) + 6 bytes (Block timestamp) + 20 bytes (Value)\n */\nabstract contract SinglePriceFeedAdapter is PriceFeedsAdapterBase {\n\n  bytes32 internal constant DATA_FROM_LATEST_UPDATE_STORAGE_LOCATION = 0x632f4a585e47073d66129e9ebce395c9b39d8a1fc5b15d4d7df2e462fb1fccfa; // keccak256(\"RedStone.singlePriceFeedAdapter\");\n  uint256 internal constant MAX_VALUE_WITH_20_BYTES = 0x000000000000000000000000ffffffffffffffffffffffffffffffffffffffff;\n  uint256 internal constant BIT_MASK_TO_CLEAR_LAST_20_BYTES = 0xffffffffffffffffffffffff0000000000000000000000000000000000000000;\n  uint256 internal constant MAX_NUMBER_FOR_48_BITS = 0x0000000000000000000000000000000000000000000000000000ffffffffffff;\n\n  error DataFeedValueTooBig(uint256 valueForDataFeed);\n\n  /**\n   * @notice Returns the only data feed identifer supported by the adapter\n   * @dev This function should be overriden in the derived contracts,\n   * but `getDataFeedIds` and `getDataFeedIndex` should not (and can not)\n   * @return dataFeedId The only data feed identifer supported by the adapter\n   */\n  function getDataFeedId() public view virtual returns (bytes32);\n\n  /**\n   * @notice Returns identifiers of all data feeds supported by the Adapter contract\n   * In this case - an array with only one element\n   * @return dataFeedIds\n   */\n  function getDataFeedIds() public view virtual override returns (bytes32[] memory dataFeedIds) {\n    dataFeedIds = new bytes32[](1);\n    dataFeedIds[0] = getDataFeedId();\n  }\n\n  /**\n   * @dev Returns 0 if dataFeedId is the one, otherwise reverts\n   * @param dataFeedId The identifier of the requested data feed\n   */\n  function getDataFeedIndex(bytes32 dataFeedId) public virtual view override returns(uint256) {\n    if (dataFeedId == getDataFeedId()) {\n      return 0;\n    }\n    revert DataFeedIdNotFound(dataFeedId);\n  }\n\n  /**\n   * @dev Reverts if proposed value for the proposed data feed id is invalid\n   * By default, it checks if the value is not equal to 0 and if it fits to 20 bytes\n   * Because other 12 bytes are used for storing the packed timestamps\n   * @param dataFeedId The data feed identifier\n   * @param valueForDataFeed Proposed value for the data feed\n   */\n  function validateDataFeedValueOnWrite(bytes32 dataFeedId, uint256 valueForDataFeed) public view virtual override {\n    super.validateDataFeedValueOnWrite(dataFeedId, valueForDataFeed);\n    if (valueForDataFeed > MAX_VALUE_WITH_20_BYTES) {\n      revert DataFeedValueTooBig(valueForDataFeed);\n    }\n  }\n\n  /**\n   * @dev [HIGH RISK] Returns the latest value for a given data feed without validation\n   * Important! Using this function instead of `getValueForDataFeed` may cause\n   * significant risk for your smart contracts\n   * @return dataFeedValue Unvalidated value of the latest successful update\n   */\n  function getValueForDataFeedUnsafe(bytes32) public view virtual override returns (uint256 dataFeedValue) {\n    uint160 dataFeedValueCompressed;\n    assembly {\n      dataFeedValueCompressed := sload(DATA_FROM_LATEST_UPDATE_STORAGE_LOCATION)\n    }\n    return uint256(dataFeedValueCompressed);\n  }\n\n  /**\n   * @notice Returns timestamps of the latest successful update\n   * @dev Timestamps here use only 6 bytes each and are packed together with the value\n   * @return dataTimestamp timestamp (usually in milliseconds) from the signed data packages\n   * @return blockTimestamp timestamp of the block when the update has happened\n   */\n  function getTimestampsFromLatestUpdate() public view virtual override returns (uint128 dataTimestamp, uint128 blockTimestamp) {\n    uint256 latestUpdateDetails;\n    assembly {\n      latestUpdateDetails := sload(DATA_FROM_LATEST_UPDATE_STORAGE_LOCATION)\n    }\n    dataTimestamp = uint128(latestUpdateDetails >> 208); // first 48 bits\n    blockTimestamp = uint128((latestUpdateDetails << 48) >> 208); // next 48 bits\n  }\n\n  /**\n   * @dev Validates and saves the value in the contract storage\n   * It uses only 20 right bytes of the corresponding storage slot\n   * @param dataFeedId The data feed identifier\n   * @param dataFeedValue Proposed value for the data feed\n   */\n  function _validateAndUpdateDataFeedValue(bytes32 dataFeedId, uint256 dataFeedValue) internal virtual override {\n    validateDataFeedValueOnWrite(dataFeedId, dataFeedValue);\n    assembly {\n      let curValueFromStorage := sload(DATA_FROM_LATEST_UPDATE_STORAGE_LOCATION)\n      curValueFromStorage := and(curValueFromStorage, BIT_MASK_TO_CLEAR_LAST_20_BYTES) // clear dataFeedValue bits\n      curValueFromStorage := or(curValueFromStorage, dataFeedValue)\n      sstore(DATA_FROM_LATEST_UPDATE_STORAGE_LOCATION, curValueFromStorage)\n    }\n  }\n\n  /**\n   * @dev Helpful function that packs and saves timestamps in the 12 left bytes of the\n   * storage slot reserved for storing details about the latest update\n   * @param dataPackagesTimestamp Timestamp from the signed data packages,\n   * extracted from the RedStone payload in calldata\n   */\n  function _saveTimestampsOfCurrentUpdate(uint256 dataPackagesTimestamp) internal virtual override {\n    uint256 blockTimestamp = getBlockTimestamp();\n\n    if (dataPackagesTimestamp > MAX_NUMBER_FOR_48_BITS) {\n      revert DataTimestampIsTooBig(dataPackagesTimestamp);\n    }\n\n    if (blockTimestamp > MAX_NUMBER_FOR_48_BITS) {\n      revert BlockTimestampIsTooBig(blockTimestamp);\n    }\n\n    uint256 timestampsPacked = dataPackagesTimestamp << 208; // 48 first bits for dataPackagesTimestamp\n    timestampsPacked |= (blockTimestamp << 160); // 48 next bits for blockTimestamp\n    assembly {\n      let latestUpdateDetails := sload(DATA_FROM_LATEST_UPDATE_STORAGE_LOCATION)\n      latestUpdateDetails := and(latestUpdateDetails, MAX_VALUE_WITH_20_BYTES) // clear timestamp bits\n      sstore(DATA_FROM_LATEST_UPDATE_STORAGE_LOCATION, or(latestUpdateDetails, timestampsPacked))\n    }\n  }\n}\n"
    },
    "contracts/RedStoneBaseContracts/redstone-oracles-monorepo/packages/on-chain-relayer/contracts/price-feeds/without-rounds/SinglePriceFeedAdapterWithClearing.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity ^0.8.14;\n\nimport {SinglePriceFeedAdapter} from \"./SinglePriceFeedAdapter.sol\";\n\n/**\n * @title [HIGH RISK] Price feed adapter for one specific data feed without\n * rounds support, with storage clearing feature\n * @author The Redstone Oracles team\n * @dev This contract has a significant security risk, as it allows to\n * update oracle data with older timestamps then the previous one. It can\n * open many opportunities for attackers to manipulate the values and use it\n * for arbitrage. Use it only if you know what you are doing very well\n */\nabstract contract SinglePriceFeedAdapterWithClearing is SinglePriceFeedAdapter {\n\n  bytes32 internal constant TEMP_DATA_TIMESTAMP_STORAGE_LOCATION = 0x9ba2e81f7980c774323961547312ae2319fc1970bb8ec60c86c869e9a1c1c0d2; // keccak256(\"RedStone.tempDataTimestampStorageLocation\");\n  uint256 internal constant MAX_VALUE_WITH_26_BYTES = 0x000000000000ffffffffffffffffffffffffffffffffffffffffffffffffffff;\n  uint256 internal constant BIT_MASK_TO_CLEAR_LAST_26_BYTES = 0xffffffffffff0000000000000000000000000000000000000000000000000000;\n\n  function validateDataFeedValueOnWrite(bytes32 dataFeedId, uint256 valueForDataFeed) public view virtual override {\n    super.validateDataFeedValueOnWrite(dataFeedId, valueForDataFeed);\n    if (valueForDataFeed > MAX_VALUE_WITH_26_BYTES) {\n      revert DataFeedValueTooBig(valueForDataFeed);\n    }\n  }\n\n  function getValueForDataFeedUnsafe(bytes32) public view override virtual returns (uint256 dataFeedValue) {\n    uint208 dataFeedValueCompressed;\n    assembly {\n      dataFeedValueCompressed := sload(DATA_FROM_LATEST_UPDATE_STORAGE_LOCATION)\n    }\n    return uint256(dataFeedValueCompressed);\n  }\n\n  function getTimestampsFromLatestUpdate() public view override virtual returns (uint128 dataTimestamp, uint128 blockTimestamp) {\n    uint256 latestUpdateDetails;\n    assembly {\n      latestUpdateDetails := sload(DATA_FROM_LATEST_UPDATE_STORAGE_LOCATION)\n    }\n    blockTimestamp = uint128(latestUpdateDetails >> 208); // first 48 bits\n    dataTimestamp = blockTimestamp * 1000; // It's a hack, because we don't store dataTimestamp in storage in this version of adapter\n  }\n\n  function getDataTimestampFromLatestUpdate() public view virtual override returns (uint256 lastDataTimestamp) {\n    assembly {\n      lastDataTimestamp := sload(TEMP_DATA_TIMESTAMP_STORAGE_LOCATION)\n    }\n  }\n\n  function _validateAndUpdateDataFeedValue(bytes32 dataFeedId, uint256 dataFeedValue) virtual internal override {\n    validateDataFeedValueOnWrite(dataFeedId, dataFeedValue);\n    uint256 blockTimestampCompressedAndShifted = getBlockTimestamp() << 208; // Move value to the first 48 bits\n    assembly {\n      // Save timestamp and data feed value\n      let timestampAndValue := or(blockTimestampCompressedAndShifted, dataFeedValue)\n      sstore(DATA_FROM_LATEST_UPDATE_STORAGE_LOCATION, timestampAndValue)\n\n      // Clear temp data timestamp, it refunds 19.9k gas\n      sstore(TEMP_DATA_TIMESTAMP_STORAGE_LOCATION, 0)\n    }\n  }\n\n  function _saveTimestampsOfCurrentUpdate(uint256 dataPackagesTimestamp)  virtual internal override {\n    assembly {\n      sstore(TEMP_DATA_TIMESTAMP_STORAGE_LOCATION, dataPackagesTimestamp)\n    }\n  }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 999999
    },
    "evmVersion": "paris",
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}